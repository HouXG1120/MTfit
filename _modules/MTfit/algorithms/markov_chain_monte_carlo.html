

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="English" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="English" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>MTfit.algorithms.markov_chain_monte_carlo &mdash; MTfit documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/style.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> MTfit
          

          
            
            <img src="../../../_static/MTfitsphinx.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                1.0.3a12
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../setup.html">2. Installing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../run.html">3. Running MTfit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">4. Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../real-tutorial.html">5. Tutorial: Real Data Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bayes.html">6. Bayesian Approach</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../probability.html">7. Probability Density Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../algorithms.html">8. Search Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mtconvert.html">9. Moment Tensor Conversion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cli.html">10. Command Line Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mtplot.html">11. Plotting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../plot_classes.html">1. Plot Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mtplotcli.html">12. MTplot Command Line Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../inversion.html">13. Inversion Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../extensions.html">14. Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">15. References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">2. Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source.html">3. Source Code</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/djpugh/MTfit">GitHub Repository</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MTfit</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>MTfit.algorithms.markov_chain_monte_carlo</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for MTfit.algorithms.markov_chain_monte_carlo</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;markov_chain_monte_carlo</span>
<span class="sd">****************************</span>
<span class="sd">Module containing algorithm classes for Markov chain Monte Carlo sampling.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="c1"># **Restricted:  For Non-Commercial Use Only**</span>
<span class="c1"># This code is protected intellectual property and is available solely for teaching</span>
<span class="c1"># and non-commercially funded academic research purposes.</span>
<span class="c1">#</span>
<span class="c1"># Applications for commercial use should be made to Schlumberger or the University of Cambridge.</span>


<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">sys</span>


<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">BaseAlgorithm</span>
<span class="kn">from</span> <span class="nn">.monte_carlo</span> <span class="k">import</span> <span class="n">IterationSample</span>
<span class="kn">from</span> <span class="nn">..probability</span> <span class="k">import</span> <span class="n">gaussian_pdf</span><span class="p">,</span> <span class="n">gaussian_cdf</span><span class="p">,</span> <span class="n">beta_pdf</span><span class="p">,</span> <span class="n">LnPDF</span>
<span class="kn">from</span> <span class="nn">..sampling</span> <span class="k">import</span> <span class="n">Sample</span>
<span class="kn">from</span> <span class="nn">..convert</span> <span class="k">import</span> <span class="n">Tape_MT33</span><span class="p">,</span> <span class="n">basic_cdc_GD</span><span class="p">,</span> <span class="n">MT33_MT6</span><span class="p">,</span> <span class="n">MT6_Tape</span>
<span class="kn">from</span> <span class="nn">..utilities.extensions</span> <span class="k">import</span> <span class="n">get_extensions</span>
<span class="kn">from</span> <span class="nn">..utilities</span> <span class="k">import</span> <span class="n">C_EXTENSION_FALLBACK_LOG_MSG</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;MTfit.algorithms&#39;</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">cmarkov_chain_monte_carlo</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">cmarkov_chain_monte_carlo</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;Error importing c extension&#39;</span><span class="p">)</span>
    <span class="n">cmarkov_chain_monte_carlo</span> <span class="o">=</span> <span class="kc">None</span>


<span class="n">_CYTHON</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">_CYTHON_TESTS</span> <span class="o">=</span> <span class="kc">False</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;McMCAlgorithmCreator&#39;</span><span class="p">,</span>
           <span class="s1">&#39;MarginalisedMarkovChainMonteCarlo&#39;</span><span class="p">,</span>
           <span class="s1">&#39;MarginalisedMetropolisHastings&#39;</span><span class="p">,</span>
           <span class="s1">&#39;MarginalisedMetropolisHastingsGaussianTape&#39;</span><span class="p">,</span>
           <span class="s1">&#39;IterativeMetropolisHastingsGaussianTape&#39;</span><span class="p">,</span>
           <span class="s1">&#39;IterativeTransDMetropolisHastingsGaussianTape&#39;</span><span class="p">,</span>
           <span class="s1">&#39;IterativeMultipleTryMetropolisHastingsGaussianTape&#39;</span><span class="p">,</span>
           <span class="s1">&#39;IterativeMultipleTryTransDMetropolisHastingsGaussianTape&#39;</span><span class="p">]</span>


<span class="c1"># Priors</span>
<span class="k">def</span> <span class="nf">zero_prior</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Evaluates uniform prior probability for x</span>

<span class="sd">    Prior is uniform over surface of 6-sphere rather than the parameterisation. Should not be called</span>

<span class="sd">    Returns</span>
<span class="sd">        float: prior probability</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">uniform_prior</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">dc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basic_cdc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">poisson</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_poisson</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">min_poisson</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Evaluates uniform prior probability for x</span>

<span class="sd">    Prior is uniform over surface of 6-sphere rather than the parameterisation.</span>

<span class="sd">    Returns</span>
<span class="sd">        float: prior probability</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Uniform samples from randomly distributed MT solutions</span>
    <span class="k">if</span> <span class="n">dc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;gamma&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">xi</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">dc</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dc</span> <span class="o">=</span> <span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="n">normalisation_constant</span> <span class="o">=</span> <span class="mf">1.10452194071529090000</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dc</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">basic_cdc</span> <span class="ow">and</span> <span class="s1">&#39;gamma&#39;</span> <span class="ow">in</span> <span class="n">xi</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">p</span> <span class="o">*=</span> <span class="mf">1.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">])</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mf">5.745</span>
        <span class="n">p</span> <span class="o">*=</span> <span class="n">beta_pdf</span><span class="p">((</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">p</span> <span class="o">*=</span> <span class="n">normalisation_constant</span>
    <span class="k">elif</span> <span class="n">basic_cdc</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">poisson</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">probability_poisson</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">max_poisson</span><span class="o">-</span><span class="n">min_poisson</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">probability_poisson</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">*=</span> <span class="mi">1</span><span class="o">/</span><span class="n">probability_poisson</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># handle infinite range for poisson</span>
                <span class="n">p</span> <span class="o">*=</span> <span class="mi">1</span>
        <span class="n">p</span> <span class="o">*=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="c1"># strike dip rake ignored as prior uniform so the ratio in the acceptance</span>
    <span class="c1"># cancels</span>
    <span class="k">return</span> <span class="n">p</span>


<span class="k">def</span> <span class="nf">flat_prior</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">dc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basic_cdc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">poisson</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_poisson</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">min_poisson</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Evaluates flat prior probability for x over parameterisation.</span>

<span class="sd">    Prior is uniform over the parameterisation.</span>

<span class="sd">    Returns</span>
<span class="sd">        float: prior probability</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># uniform flat prior over parameters</span>
    <span class="k">if</span> <span class="n">dc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;gamma&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">xi</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">dc</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dc</span> <span class="o">=</span> <span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dc</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">basic_cdc</span> <span class="ow">and</span> <span class="s1">&#39;gamma&#39;</span> <span class="ow">in</span> <span class="n">xi</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">p</span> <span class="o">*=</span> <span class="mi">3</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">p</span> <span class="o">*=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">elif</span> <span class="n">basic_cdc</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">poisson</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">probability_poisson</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">max_poisson</span><span class="o">-</span><span class="n">min_poisson</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">probability_poisson</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">*=</span> <span class="mi">1</span><span class="o">/</span><span class="n">probability_poisson</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># handle infinite range for poisson</span>
                <span class="n">p</span> <span class="o">*=</span> <span class="mi">1</span>  <span class="c1"># WRONG BUT CAN BE USED (unnormalised but balanced)</span>
        <span class="n">p</span> <span class="o">*=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="c1"># strike dip rake ignored as prior uniform so the ratio in the acceptance</span>
    <span class="c1"># cancels</span>
    <span class="k">return</span> <span class="n">p</span>


<span class="k">class</span> <span class="nc">DataError</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="McMCAlgorithmCreator"><a class="viewcode-back" href="../../../markov_chain_monte_carlo.html#MTfit.algorithms.markov_chain_monte_carlo.McMCAlgorithmCreator">[docs]</a><span class="k">class</span> <span class="nc">McMCAlgorithmCreator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates the Markov chain Monte Carlo algorithm from parameters</span>

<span class="sd">    Creates the correct McMC algorithm object depending on the selected mode.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="McMCAlgorithmCreator.__new__"><a class="viewcode-back" href="../../../markov_chain_monte_carlo.html#MTfit.algorithms.markov_chain_monte_carlo.McMCAlgorithmCreator.__new__">[docs]</a>    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;metropolis_hastings&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">trans_dimensional</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">learning_length</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">parameterisation</span><span class="o">=</span><span class="s1">&#39;tape&#39;</span><span class="p">,</span> <span class="n">transition</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">,</span>
                <span class="n">chain_length</span><span class="o">=</span><span class="mi">1000000</span><span class="p">,</span> <span class="n">min_acceptance_rate</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">max_acceptance_rate</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                <span class="n">acceptance_rate_window</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">initial_sample</span><span class="o">=</span><span class="s1">&#39;grid&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        McMC Creator</span>

<span class="sd">        Returns initialised object of desired type. This is extensible using the</span>
<span class="sd">        MTfit.algorithms.markov_chain_monte_carlo group in pkg_resources (see extensions documentation)</span>
<span class="sd">        to add additional options</span>

<span class="sd">        Args</span>
<span class="sd">            mode:[MetropolisHastings] McMC mode to use options are: MetropolisHastings</span>
<span class="sd">            alpha:[False] Default parameters for Markov chain steps, depend on transition probabilities</span>
<span class="sd">            trans_dimensional:[False] Boolean flag to run with trans-dimensional sampling</span>
<span class="sd">            learning_length:[10000] Number of samples for learning period and to discard from chain.</span>
<span class="sd">            parameterisation:[&#39;Tape&#39;] Source type parameterisation to use options are: Tape</span>
<span class="sd">            transition:[&#39;Gaussian&#39;] Transition pdf to use options are: &#39;Gaussian&#39;</span>
<span class="sd">            chain_length:[1000000] End point of the Markov chain.</span>
<span class="sd">            min_acceptance_rate:[0.3] Minimum targetted sample acceptance rate.</span>
<span class="sd">            max_acceptance_rate:[0.5] Maximum targetted sample acceptance rate.</span>
<span class="sd">            acceptance_rate_window:[1000] Number of samples to use in learning period for calculating and</span>
<span class="sd">                modifying the acceptance rate.</span>
<span class="sd">            initial_sample:[&#39;Grid&#39;] Initialisation sampling mode to use options are &#39;Grid&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">            McMC sampling object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">algorithm_names</span><span class="p">,</span> <span class="n">algorithms</span><span class="p">)</span> <span class="o">=</span> <span class="n">get_extensions</span><span class="p">(</span><span class="s1">&#39;MTfit.directed_algorithms&#39;</span><span class="p">)</span>
        <span class="c1"># McMC algorithms included in this file</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;metropolis_hastings&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">parameterisation</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;tape&#39;</span> <span class="ow">and</span> <span class="n">transition</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
            <span class="n">number_samples</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;number_samples&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">number_samples</span><span class="p">:</span>  <span class="c1"># or kwargs.get(&#39;multiple_events&#39;,False):</span>
                <span class="k">if</span> <span class="n">trans_dimensional</span><span class="p">:</span>
                    <span class="n">dimension_jump_prob</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dimension_jump_prob&#39;</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">IterativeTransDMetropolisHastingsGaussianTape</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">learning_length</span><span class="o">=</span><span class="n">learning_length</span><span class="p">,</span>
                                                                         <span class="n">chain_length</span><span class="o">=</span><span class="n">chain_length</span><span class="p">,</span>
                                                                         <span class="n">min_acceptance_rate</span><span class="o">=</span><span class="n">min_acceptance_rate</span><span class="p">,</span>
                                                                         <span class="n">max_acceptance_rate</span><span class="o">=</span><span class="n">max_acceptance_rate</span><span class="p">,</span>
                                                                         <span class="n">initial_sample</span><span class="o">=</span><span class="n">initial_sample</span><span class="p">,</span>
                                                                         <span class="n">acceptance_rate_window</span><span class="o">=</span><span class="n">acceptance_rate_window</span><span class="p">,</span>
                                                                         <span class="n">dimension_jump_prob</span><span class="o">=</span><span class="n">dimension_jump_prob</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># if kwargs.get(&#39;multiple_events&#39;, False):</span>
                    <span class="c1">#     return IterativeMultipleEventJointMetropolisHastingsGaussianTape(alpha=alpha, learning_length=learning_length,</span>
                    <span class="c1">#                                                                      chain_length=chain_length,</span>
                    <span class="c1">#                                                                      min_acceptance_rate=min_acceptance_rate,</span>
                    <span class="c1">#                                                                      max_acceptance_rate=max_acceptance_rate,</span>
                    <span class="c1">#                                                                      initial_sample=initial_sample,</span>
                    <span class="c1">#                                                                      acceptance_rate_window=acceptance_rate_window,</span>
                    <span class="c1">#                                                                      **kwargs)</span>
                    <span class="k">return</span> <span class="n">IterativeMetropolisHastingsGaussianTape</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">learning_length</span><span class="o">=</span><span class="n">learning_length</span><span class="p">,</span> <span class="n">chain_length</span><span class="o">=</span><span class="n">chain_length</span><span class="p">,</span>
                                                                   <span class="n">min_acceptance_rate</span><span class="o">=</span><span class="n">min_acceptance_rate</span><span class="p">,</span> <span class="n">max_acceptance_rate</span><span class="o">=</span><span class="n">max_acceptance_rate</span><span class="p">,</span>
                                                                   <span class="n">initial_sample</span><span class="o">=</span><span class="n">initial_sample</span><span class="p">,</span> <span class="n">acceptance_rate_window</span><span class="o">=</span><span class="n">acceptance_rate_window</span><span class="p">,</span>
                                                                   <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">trans_dimensional</span><span class="p">:</span>
                    <span class="n">dimension_jump_prob</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dimension_jump_prob&#39;</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">IterativeMultipleTryTransDMetropolisHastingsGaussianTape</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">learning_length</span><span class="o">=</span><span class="n">learning_length</span><span class="p">,</span>
                                                                                    <span class="n">chain_length</span><span class="o">=</span><span class="n">chain_length</span><span class="p">,</span>
                                                                                    <span class="n">min_acceptance_rate</span><span class="o">=</span><span class="n">min_acceptance_rate</span><span class="p">,</span>
                                                                                    <span class="n">max_acceptance_rate</span><span class="o">=</span><span class="n">max_acceptance_rate</span><span class="p">,</span>
                                                                                    <span class="n">initial_sample</span><span class="o">=</span><span class="n">initial_sample</span><span class="p">,</span>
                                                                                    <span class="n">acceptance_rate_window</span><span class="o">=</span><span class="n">acceptance_rate_window</span><span class="p">,</span>
                                                                                    <span class="n">dimension_jump_prob</span><span class="o">=</span><span class="n">dimension_jump_prob</span><span class="p">,</span>
                                                                                    <span class="n">number_samples</span><span class="o">=</span><span class="n">number_samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">IterativeMultipleTryMetropolisHastingsGaussianTape</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">learning_length</span><span class="o">=</span><span class="n">learning_length</span><span class="p">,</span>
                                                                              <span class="n">chain_length</span><span class="o">=</span><span class="n">chain_length</span><span class="p">,</span>
                                                                              <span class="n">min_acceptance_rate</span><span class="o">=</span><span class="n">min_acceptance_rate</span><span class="p">,</span>
                                                                              <span class="n">max_acceptance_rate</span><span class="o">=</span><span class="n">max_acceptance_rate</span><span class="p">,</span>
                                                                              <span class="n">initial_sample</span><span class="o">=</span><span class="n">initial_sample</span><span class="p">,</span>
                                                                              <span class="n">acceptance_rate_window</span><span class="o">=</span><span class="n">acceptance_rate_window</span><span class="p">,</span>
                                                                              <span class="n">number_samples</span><span class="o">=</span><span class="n">number_samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Extension options - Pass all arguments through</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">algorithm_names</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">algorithms</span><span class="p">[</span><span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()](</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">trans_dimensional</span><span class="o">=</span><span class="n">trans_dimensional</span><span class="p">,</span> <span class="n">learning_length</span><span class="o">=</span><span class="n">learning_length</span><span class="p">,</span>
                                            <span class="n">parameterisation</span><span class="o">=</span><span class="n">parameterisation</span><span class="p">,</span> <span class="n">transition</span><span class="o">=</span><span class="n">transition</span><span class="p">,</span> <span class="n">chain_length</span><span class="o">=</span><span class="n">chain_length</span><span class="p">,</span>
                                            <span class="n">min_acceptance_rate</span><span class="o">=</span><span class="n">min_acceptance_rate</span><span class="p">,</span> <span class="n">max_acceptance_rate</span><span class="o">=</span><span class="n">max_acceptance_rate</span><span class="p">,</span>
                                            <span class="n">acceptance_rate_window</span><span class="o">=</span><span class="n">acceptance_rate_window</span><span class="p">,</span> <span class="n">initial_sample</span><span class="o">=</span><span class="n">initial_sample</span><span class="p">,</span>
                                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Defaults</span>
            <span class="k">return</span> <span class="n">IterativeMetropolisHastingsGaussianTape</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">learning_length</span><span class="o">=</span><span class="n">learning_length</span><span class="p">,</span> <span class="n">chain_length</span><span class="o">=</span><span class="n">chain_length</span><span class="p">,</span>
                                                           <span class="n">min_acceptance_rate</span><span class="o">=</span><span class="n">min_acceptance_rate</span><span class="p">,</span> <span class="n">max_acceptance_rate</span><span class="o">=</span><span class="n">max_acceptance_rate</span><span class="p">,</span>
                                                           <span class="n">acceptance_rate_window</span><span class="o">=</span><span class="n">acceptance_rate_window</span><span class="p">,</span>
                                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">MarginalisedMarkovChainMonteCarlo</span><span class="p">(</span><span class="n">BaseAlgorithm</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Marginalised Markov chain Monte Carlo Algorithm</span>

<span class="sd">    Markov chain constructed from marginalised MT dist (p(M) not p(M|A), i.e. marginalised over station parameters.</span>

<span class="sd">    Default object with basic functions added</span>

<span class="sd">    This is a child class of the BaseAlgorithm</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Returns zero for testing - should be set in __init__</span>
    <span class="n">default_sampling_priors</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;uniform_prior&#39;</span><span class="p">:</span> <span class="n">zero_prior</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialisation of marginalised Markov chain Monte Carlo Algorithm</span>

<span class="sd">        Keyword Args</span>
<span class="sd">            alpha:[1] Default parameters for Markov chain steps, depend on transition probabilities</span>
<span class="sd">            learning_length:[10000] Number of samples for learning period and to discard from chain.</span>
<span class="sd">            min_acceptance_rate:[0.3] Minimum targetted sample acceptance rate.</span>
<span class="sd">            max_acceptance_rate:[0.5] Maximum targetted sample acceptance rate.</span>
<span class="sd">            acceptance_rate_window:[100] Number of samples to use in learning period for calculating and modifying the acceptance rate.</span>
<span class="sd">            max_alpha:[100] Maximum values for alpha to take.</span>
<span class="sd">            sampling_prior:[&#39;uniform_prior&#39;] String to select the prior to use - the default is the uniform prior (Uniform over 6-sphere surface, not parameterisation).</span>
<span class="sd">            initial_sample:[None] Initial sample can be set if determined by some other method.</span>
<span class="sd">            diagnostic_output:[False] Set algorithm to output all information on iterations - for testing/plotting and debugging.</span>
<span class="sd">            min_number_initialisation_samples:[30000] Minimum number of samples for grid based iteration sampler.</span>
<span class="sd">            number_samples:[10000] Number of samples to use for each iteration of the grid sampler.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MarginalisedMarkovChainMonteCarlo</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mcmc</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number_samples</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tried</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_accepted</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Number of learning samples accepted</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_number_learning_accepted</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_number_initialisation_samples</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min_number_initialisation_samples&#39;</span><span class="p">,</span> <span class="mi">30000</span><span class="p">)</span>
        <span class="c1"># Handle initial sampling - either random sampling or single</span>
        <span class="c1"># sampling/initial sample.</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;initial_sample&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;grid&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span> <span class="o">=</span> <span class="n">IterationSample</span><span class="p">(</span><span class="n">number_samples</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;number_samples&#39;</span><span class="p">,</span> <span class="mi">10000</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialising</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_number_initialisation_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialising</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;initial_sample&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Default attribute initialisation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_alpha&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning_length</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;learning_length&#39;</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_acceptance_rate</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min_acceptance_rate&#39;</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_old_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_acceptance_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_acceptance_rate</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_acceptance_rate&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate_window</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;acceptance_rate_window&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;diagnostic_output&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_nonzero</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_initialisation_probability</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_max_mt</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_dc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Debug flag - adds learning samples and learning results etc to output</span>
        <span class="c1"># (large data size)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bis&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">))),</span> <span class="p">[]],</span> <span class="s1">&#39;bit&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;bir&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;cs&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">))),</span> <span class="p">[]]}</span>
        <span class="c1"># Sets prior function as uniform prior</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor_i</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Multiple events</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pdf_sample</span> <span class="o">=</span> <span class="n">Sample</span><span class="p">(</span><span class="n">number_events</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">)</span>
            <span class="n">all_alpha</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">dc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dc</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">):</span>
                <span class="n">all_alpha</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p_dc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">all_alpha</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_init_max_mt</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_max_initialisation_probability</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_init_nonzero</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span><span class="o">.</span><span class="n">number_events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">total_number_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tried</span>

    <span class="k">def</span> <span class="nf">acceptance_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets acceptance rate.</span>

<span class="sd">        Returns</span>
<span class="sd">            float: acceptance rate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_learning_accepted</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_length</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tried</span><span class="p">:</span>
                <span class="n">rate</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="p">))</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accepted</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tried</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="n">rate</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">rate</span>

    <span class="k">def</span> <span class="nf">_get_acceptance_rate_modifier</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets values for modifying alpha and hence acceptance rate.</span>

<span class="sd">        Returns</span>
<span class="sd">            float: ratio of actual rate to min or max targetted acceptance rate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">rate</span> <span class="ow">and</span> <span class="n">rate</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rate</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_acceptance_rate</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_old_rate</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_acceptance_rate</span> <span class="ow">and</span> <span class="n">rate</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_rate</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_rate</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_acceptance_rate</span><span class="p">:</span>
                    <span class="n">rate</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="n">rate</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">min_acceptance_rate</span>
            <span class="k">elif</span> <span class="n">rate</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_acceptance_rate</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_old_rate</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_acceptance_rate</span> <span class="ow">and</span> <span class="n">rate</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_rate</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_rate</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_acceptance_rate</span><span class="p">:</span>
                    <span class="n">rate</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="n">rate</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">max_acceptance_rate</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ratio</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rate</span> <span class="ow">and</span> <span class="n">rate</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_old_rate</span> <span class="o">=</span> <span class="n">rate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_old_ratio</span> <span class="o">=</span> <span class="n">ratio</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_old_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_old_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_old_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
        <span class="k">if</span> <span class="n">rate</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># revert to old alpha and change ratio</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_alpha</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># list</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_alpha</span><span class="p">[:]</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_old_ratio</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_old_ratio</span> <span class="o">=</span> <span class="n">ratio</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">rate</span><span class="p">:</span>
            <span class="c1"># revert to old alpha and change ratio</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_alpha</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># list</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_alpha</span><span class="p">[:]</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_ratio</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_old_ratio</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_old_ratio</span> <span class="o">=</span> <span class="n">ratio</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">ratio</span>

    <span class="k">def</span> <span class="nf">output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns output dictionary</span>

<span class="sd">        Returns</span>
<span class="sd">            dict: Output dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;discard&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
        <span class="n">output</span><span class="p">,</span> <span class="n">output_string</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">MarginalisedMarkovChainMonteCarlo</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;acceptance_rate&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate</span><span class="p">()})</span>
        <span class="n">output</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;accepted&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accepted</span><span class="p">})</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">output</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">})</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="n">output</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;debug_output&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">})</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;ln_bayesian_evidence&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">output_string</span>

    <span class="k">def</span> <span class="nf">_modify_acceptance_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">non_zero_percentage</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjusts the acceptance rate parameters based on the targetted acceptance rate.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">non_zero_percentage</span><span class="p">:</span>
            <span class="c1"># Modifies alpha by initial non-zero percentage from initialising</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">non_zero_percentage</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_acceptance_rate_modifier</span><span class="p">()</span>
        <span class="c1"># ratio=min(ratio,2.0)#sanity check bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_modify_alpha</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="n">ratio</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_modify_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">ratio</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modifies the transition PDF parameters based on the ratio argument</span>
<span class="sd">        The alpha argument is increased up to some max_alpha value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">newAlpha</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">alpha</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;gamma_dc&#39;</span><span class="p">,</span> <span class="s1">&#39;delta_dc&#39;</span><span class="p">,</span> <span class="s1">&#39;proposal_normalisation&#39;</span><span class="p">]:</span>
                    <span class="n">newAlpha</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">*</span><span class="n">ratio</span>
                    <span class="k">if</span> <span class="n">newAlpha</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_alpha</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                        <span class="n">newAlpha</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">newAlpha</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">alph</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">alpha</span><span class="p">):</span>
                <span class="n">newAlpha</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_modify_alpha</span><span class="p">(</span><span class="n">alph</span><span class="p">,</span> <span class="n">ratio</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newAlpha</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">*</span><span class="n">ratio</span>
            <span class="k">if</span> <span class="n">newAlpha</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_alpha</span><span class="p">:</span>
                <span class="n">newAlpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="k">return</span> <span class="n">newAlpha</span>

    <span class="k">def</span> <span class="nf">transition_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates transition probability for x and x1</span>

<span class="sd">        Returns</span>
<span class="sd">            float: transition probability</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">prior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates prior probability for x</span>

<span class="sd">        Returns</span>
<span class="sd">            float: prior probability</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prior</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">new_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates new sample</span>

<span class="sd">        Returns</span>
<span class="sd">            New sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">acceptance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ln_likelihoodx</span><span class="p">,</span> <span class="n">dc_prior</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate acceptance for x given ln_likelihoodx</span>

<span class="sd">        Args</span>
<span class="sd">            x: Model values</span>
<span class="sd">            ln_likelihoodx: Model ln_likelihood.</span>

<span class="sd">        Returns</span>
<span class="sd">            float:acceptance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_acceptance_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">scale_factori_1</span><span class="p">,</span> <span class="n">dc_prior</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate acceptance&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance</span><span class="p">(</span><span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">dc_prior</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">scale_factori_1</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{},</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">learning_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if still in learning period&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_learning_accepted</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_length</span>

    <span class="k">def</span> <span class="nf">_add_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add old result (not accepting test result)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">():</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;bis&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;cs&#39;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor_i</span><span class="p">)</span>
        <span class="c1"># Not adding to accepted, as want length of unique samples for chain</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">():</span>
            <span class="c1"># add a zero to learning acceptance list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">scale_factori_1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add new result (accepting new value)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">():</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;bis&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;cs&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="n">xi_1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add</span><span class="p">(</span><span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">scale_factori_1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_accepted</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_number_learning_accepted</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">scale_factori_1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add result xi_1 with ln_pdf ln_pi_1&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="o">=</span> <span class="n">xi_1</span>  <span class="c1"># Set new sample to old sample</span>
        <span class="c1"># set old ln_likelihood to new ln_likelihood</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">)</span>
        <span class="c1"># MULTIPLE_EVENTS</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">):</span>
                <span class="k">if</span> <span class="s1">&#39;gamma&#39;</span> <span class="ow">in</span> <span class="n">xi</span> <span class="ow">and</span> <span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">():</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">p_dc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># TODO handle warning about element wise comparison - sometimes output is a single element array</span>
        <span class="c1"># need to tidy output/array passing</span>
        <span class="k">elif</span> <span class="s1">&#39;gamma&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p_dc</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dc</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dc</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor_i</span> <span class="o">=</span> <span class="n">scale_factori_1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pdf_sample</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="n">xi_1</span><span class="p">),</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">scale_factori_1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tried</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">iterate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate from result</span>

<span class="sd">        Args</span>
<span class="sd">            result: Result dictionary from forward task (e.g. MTfit.inversion.ForwardTask)</span>

<span class="sd">        Returns</span>
<span class="sd">            new_sample,End where End is a boolean flag to end the chain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Check if in initialisation stage</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialising</span><span class="p">:</span>
                <span class="c1"># Check number samples with max prob.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">maximum_initialisation_probability</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">u</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_initialisation_probability</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">maximum_initialisation_probability</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_initialisation_probability</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="c1"># Multiple events</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">individual_result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
                        <span class="n">ln_pdf</span> <span class="o">=</span> <span class="n">individual_result</span><span class="p">[</span><span class="s1">&#39;ln_pdf&#39;</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_pdf</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                            <span class="n">ln_pdf</span> <span class="o">=</span> <span class="n">LnPDF</span><span class="p">(</span><span class="n">ln_pdf</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ln_pdf</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_init_nonzero</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ln_pdf</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())</span>
                            <span class="c1"># Check if number of initialisation samples&lt;desired</span>
                            <span class="c1"># number or if there are no non-zero probability</span>
                            <span class="c1"># samples</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_initialisation_samples</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_number_initialisation_samples</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">maximum_initialisation_probability</span><span class="p">:</span>
                                <span class="c1"># Update max_prob/mt combinations for each</span>
                                <span class="c1"># event</span>
                                <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">ln_pdf</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ln_pdf</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_initialisation_probability</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_max_initialisation_probability</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ln_pdf</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ln_pdf</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_init_max_mt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">individual_result</span><span class="p">[</span><span class="s1">&#39;moment_tensors&#39;</span><span class="p">][:,</span> <span class="n">ln_pdf</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="c1"># Single event or full joint PDF initialisation</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ln_pdf</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;ln_pdf&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_pdf</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                        <span class="n">ln_pdf</span> <span class="o">=</span> <span class="n">LnPDF</span><span class="p">(</span><span class="n">ln_pdf</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ln_pdf</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_init_nonzero</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ln_pdf</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())</span>
                        <span class="c1"># Check if number of initialisation samples&lt;desired</span>
                        <span class="c1"># number or if there are no non-zero probability</span>
                        <span class="c1"># samples</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_initialisation_samples</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_number_initialisation_samples</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">maximum_initialisation_probability</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">ln_pdf</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ln_pdf</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_initialisation_probability</span><span class="p">:</span>
                                <span class="c1"># Update max_prob/mt combinations for the event</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_max_initialisation_probability</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ln_pdf</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ln_pdf</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
                                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;moment_tensors&#39;</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_init_max_mt</span> <span class="o">=</span> <span class="p">[]</span>
                                    <span class="k">for</span> <span class="n">mt</span> <span class="ow">in</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;moment_tensors&#39;</span><span class="p">]:</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">_init_max_mt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mt</span><span class="p">[:,</span> <span class="n">ln_pdf</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_init_max_mt</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;moment_tensors&#39;</span><span class="p">][:,</span> <span class="n">ln_pdf</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="c1"># Do quality check and chek if init_max p&gt;0</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">maximum_initialisation_probability</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">u</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_initialisation_probability</span><span class="p">])</span>
                    <span class="n">quality_check_ok</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="mi">100</span><span class="o">*</span><span class="nb">float</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_number_initialisation_samples</span><span class="p">)</span> <span class="o">&gt;</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">quality_check</span> <span class="k">for</span> <span class="n">nz</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_nonzero</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">maximum_initialisation_probability</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_initialisation_probability</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                    <span class="n">quality_check_ok</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_nonzero</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_number_initialisation_samples</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">quality_check</span>
                <span class="c1"># Check if number of initialisation samples&gt;desired number and</span>
                <span class="c1"># there are non-zero prob samples</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_initialisation_samples</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_number_initialisation_samples</span> <span class="ow">and</span> <span class="n">maximum_initialisation_probability</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quality_check</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quality_check</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">quality_check</span><span class="p">)</span> <span class="ow">and</span> <span class="n">quality_check_ok</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;Data Error: Non-zero sample percentage above </span><span class="si">{}</span><span class="s2">%&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quality_check</span><span class="p">))</span>
                    <span class="c1"># Have solutions - initialising finished</span>
                    <span class="c1"># ADD LOGIC FOR PERCENTAGE NON-ZERO</span>
                    <span class="c1"># Need to get and keep track of number of samples</span>
                    <span class="c1"># Get percentage non-zero for initialisation and modify the alpha0 values appropriately -</span>
                    <span class="c1">#   Large % larger alpha</span>
                    <span class="c1">#   Small % smaller alpha</span>
                    <span class="c1">#</span>
                    <span class="c1"># Simplest is probably to just multiply by decimal of non-zero samples if multiple events</span>
                    <span class="c1"># self._modify_acceptance_rate(float(self._init_nonzero)/float(self._number_initialisation_samples))</span>
                    <span class="c1"># ADDED DJP 1/9/14 - check values  - killed as alpha large already</span>
                    <span class="c1">#</span>
                    <span class="c1"># Convert initial sample</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_max_mt</span><span class="p">)</span>
                    <span class="c1"># Initialise samples</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>
                    <span class="c1"># As this will always be accepted as initial sample</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_tried</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="c1"># Set ln_likelihood so accepted</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor_i</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_initialising</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="c1"># Print initialisation output</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span><span class="p">:</span>
                        <span class="n">nonzero_events</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nonzero</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_nonzero</span><span class="p">):</span>
                            <span class="n">nonzero_events</span> <span class="o">+=</span> <span class="s1">&#39;Event </span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1">% -&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="nb">float</span><span class="p">(</span><span class="n">nonzero</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_number_initialisation_samples</span><span class="p">))[:</span><span class="mi">3</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">nonzero_events</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_nonzero</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_number_initialisation_samples</span><span class="p">))[:</span><span class="mi">3</span><span class="p">])</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Algorithm initialised (Percentage non-zero - </span><span class="si">{}</span><span class="s1">) - Starting learning period</span><span class="se">\n</span><span class="s1">---------&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nonzero_events</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="c1"># Debug output (large data size)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="s1">&#39;bis&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="s1">&#39;bis&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_max_mt</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># Set t0 after initialisation</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">),</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialise</span><span class="p">()</span>
            <span class="c1"># Not in initialisation - main McMC part</span>
            <span class="c1"># Check for non-zero MT solutions</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;ln_pdf&#39;</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;ln_pdf&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                <span class="n">ln_pi_1</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;ln_pdf&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                    <span class="n">ln_pi_1</span> <span class="o">=</span> <span class="n">LnPDF</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">)</span>
                <span class="c1"># assume marginalised</span>
                <span class="c1"># Check acceptance (multiple tried events possible) returns</span>
                <span class="c1"># accepted sample or empty dict if none accepted</span>
                <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">scale_factor_i</span><span class="p">,</span> <span class="n">tried</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_acceptance_check</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;scale_factor&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
                <span class="c1"># returns dict not array/list of arrays</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi_1</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">xi_1</span><span class="p">])</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi_1</span><span class="p">)):</span>
                    <span class="c1"># Handling for multiple tries (agnostic)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tried</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="c1"># Add old samples for tried but not accepted samples</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_add_old</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_new</span><span class="p">(</span><span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">scale_factor_i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Handling for multiple tries (agnostic)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tried</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="c1"># Add old samples for tried but not accepted samples</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_add_old</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_old</span><span class="p">()</span>  <span class="c1"># Add old sample as non-accepted</span>
            <span class="c1"># Check if need to do learning transition PDF update</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate_window</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_modify_acceptance_rate</span><span class="p">()</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Learning </span><span class="si">{:.4f}% c</span><span class="s1">omplete - this learning iteration: </span><span class="si">{}</span><span class="s1"> accepted and </span><span class="si">{}</span><span class="s1">  tried - acceptance rate: </span><span class="si">{:.6f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_number_learning_accepted</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_length</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate</span><span class="p">()))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>  <span class="c1"># Append rate info to Debug output</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="s1">&#39;bir&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span>
                        <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate_window</span><span class="p">:]))</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate_window</span><span class="p">:]))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="s1">&#39;bit&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">tx</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tx</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Not in learning</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tried</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># First sample</span>
                    <span class="c1"># Check and modify transition PDF parameters if within 25%</span>
                    <span class="c1"># of the acceptance_rate_window</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate_window</span><span class="p">:])</span> <span class="o">&gt;</span> <span class="mf">0.75</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate_window</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="p">[</span>
                            <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate_window</span><span class="p">:]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_modify_acceptance_rate</span><span class="p">()</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Learning complete - this learning iteration: </span><span class="si">{}</span><span class="s1"> accepted and </span><span class="si">{}</span><span class="s1"> tried - acceptance rate: </span><span class="si">{:.6f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate</span><span class="p">()))</span>
                    <span class="c1"># Print out initialisation completion</span>
                    <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Learning elapsed time: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">))</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Starting main inversion</span><span class="se">\n</span><span class="s2">---------&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">t1</span>
                    <span class="c1"># Add sample (added to saved chain)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor_i</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tried</span> <span class="o">%</span> <span class="mi">100</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> samples tried: </span><span class="si">{}</span><span class="s1"> samples accepted&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tried</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accepted</span><span class="p">))</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_sample</span><span class="p">(),</span> <span class="kc">False</span>
        <span class="c1"># Error handling</span>
        <span class="k">except</span> <span class="ne">MemoryError</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Memory Error, forcing garbage collection and trying again&#39;</span><span class="p">)</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="n">DataError</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;Error with data&#39;</span><span class="p">)</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">initialise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialse samples</span>

<span class="sd">        Initialises the chain either using an initialiser if set, otherwise using random_sample.</span>

<span class="sd">        Returns</span>
<span class="sd">            new_sample,False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialiser - use initialise() function in the initialiser algorithm</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialising</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_number_initialisation_samples</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span><span class="o">.</span><span class="n">number_samples</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span><span class="o">.</span><span class="n">initialise</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span>
        <span class="c1"># Set initialse sample parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tried</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># As this will always be accepted as initial sample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor_i</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">),</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_convert_sample_single</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts single event sample to MT form</span>

<span class="sd">        Args</span>
<span class="sd">            x: sample</span>

<span class="sd">        Returns</span>
<span class="sd">            Converted Sample</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts sample to MT form</span>

<span class="sd">        Args</span>
<span class="sd">            x: sample</span>

<span class="sd">        Returns</span>
<span class="sd">            Converted Sample</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="o">*</span><span class="mi">6</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;shape of x &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; must match the number of events&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># dict(zip([&#39;gamma&#39;,&#39;delta&#39;,&#39;kappa&#39;,&#39;h&#39;,&#39;sigma&#39;],MT6_Tape(x)))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_sample_single</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">):</span>
                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert_sample_single</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">6</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">6</span><span class="p">,</span> <span class="p">:]))</span>
            <span class="k">return</span> <span class="n">data</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">X</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert_sample_single</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_sample_single</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MarginalisedMetropolisHastings</span><span class="p">(</span><span class="n">MarginalisedMarkovChainMonteCarlo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Marginalised Metropolis Hastings Markov chain Monte Carlo Algorithm</span>

<span class="sd">    Markov chain constructed using the Metropolis Hastings method from the marginalised PDF (p(M) not p(M|A), i.e. marginalised over station parameters.</span>

<span class="sd">    This is a child class of the MarginalisedMarkovChainMonteCarlo</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">acceptance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ln_likelihood_x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates acceptance</span>

<span class="sd">        Calculates the acceptance from the Metropolis condition.</span>

<span class="sd">        Args</span>
<span class="sd">            x: Model values</span>
<span class="sd">            ln_likelihood_x: Model ln_likelihood.</span>

<span class="sd">        Returns</span>
<span class="sd">            float:acceptance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">LnPDF</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_likelihood_x</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">LnPDF</span><span class="p">)):</span>
            <span class="n">ln_likelihood_x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ln_likelihood_x</span><span class="p">)</span>
        <span class="c1"># Handle multiple events</span>
        <span class="k">if</span> <span class="n">ln_likelihood_x</span> <span class="o">==</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[:]</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">_numerator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_pdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">_denominator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">acc</span> <span class="o">*=</span> <span class="n">_numerator</span><span class="o">/</span><span class="n">_denominator</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[:]</span>
                    <span class="c1"># 0 probability values for acceptance denominator so acc is</span>
                    <span class="c1"># infinite --&gt; set to 1</span>
                    <span class="k">return</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[:]</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">acc</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ln_likelihood_x</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># ln likelihoods</span>
            <span class="n">acceptance</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transition_pdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transition_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">))</span>
            <span class="n">acceptance</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ln_likelihood_x</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">acceptance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 0 probability values for acceptance denominator so acc is</span>
            <span class="c1"># infinite --&gt; set to 1</span>
            <span class="k">return</span> <span class="mi">1</span>


<span class="k">class</span> <span class="nc">MarginalisedMetropolisHastingsGaussianTape</span><span class="p">(</span><span class="n">MarginalisedMetropolisHastings</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Marginalised Metropolis Hastings Markov chain Monte Carlo Algorithm using Gaussian transition PDF and Tape and Tape parameterisation</span>

<span class="sd">    Markov chain constructed using the Metropolis Hastings method from the marginalised pdf (p(M) not p(M|A), i.e. marginalised over station parameters.</span>
<span class="sd">    The transition pdf is gaussian and the parameterisation is from Tape and Tape (A geometric setting for moment tensors, Tape and Tape, 2012, GJI 190 pp 476-490).</span>

<span class="sd">    This is a child class of the MarginalisedMetropolisHastings</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialisation of marginalised Metropolis Hastings Markov chain Monte Carlo Algorithm using gaussian transition pdf and Tape source parameterisation.</span>

<span class="sd">        Keyword Args</span>
<span class="sd">            alpha: Default parameters for Markov chain steps, depend on transition probabilities Default parameters are:</span>
<span class="sd">                    {&#39;kappa&#39;:np.pi/5,&#39;h&#39;:0.2,&#39;sigma&#39;:np.pi/10,&#39;gamma&#39;:np.pi/15,</span>
<span class="sd">                     &#39;delta&#39;:np.pi/10,&#39;alpha&#39;:np.pi/10,&#39;poisson&#39;:0.2}</span>
<span class="sd">            max_alpha: Maximum values for alpha to take. Default parameters are:</span>
<span class="sd">                    {&#39;kappa&#39;:np.pi/2,&#39;h&#39;:0.5,&#39;sigma&#39;:np.pi/4,&#39;gamma&#39;:np.pi/12,&#39;delta&#39;:np.pi/4,</span>
<span class="sd">                     &#39;alpha&#39;:np.pi/4,&#39;poisson&#39;:0.1}</span>
<span class="sd">            poisson:[0.25] poisson ratio for CDC model.</span>
<span class="sd">            min_poisson:[-np.inf] Minimum poisson ratio for CDC model.</span>
<span class="sd">            max_poisson:[np.inf] Maximum poisson ratio for CDC model.</span>

<span class="sd">        This is a child class of the MarginalisedMetropolisHastings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_sampling_priors</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;uniform_prior&#39;</span><span class="p">:</span> <span class="n">uniform_prior</span><span class="p">,</span> <span class="s1">&#39;flat_prior&#39;</span><span class="p">:</span> <span class="n">flat_prior</span><span class="p">}</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MarginalisedMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;kappa&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">15</span><span class="p">,</span>
                      <span class="s1">&#39;delta&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;poisson&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">}</span>
        <span class="c1"># Set up alpha for multiple events</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">all_alpha</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">):</span>
                <span class="n">all_alpha</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">all_alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_alpha</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;kappa&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">12</span><span class="p">,</span>
                          <span class="s1">&#39;delta&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;poisson&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">}</span>
        <span class="c1"># Reflect PDFs off upper limit - maintains uniformity in transition PDF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_gamma</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reflect_gamma&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_delta</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reflect_delta&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_sigma</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reflect_sigma&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_dip</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reflect_dip&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="c1"># alpha is the opening crack angle in the CDC model - it takes values</span>
        <span class="c1"># from -pi/2 to pi/2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reflect_alpha&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="c1"># N.B. reflecting works because</span>
        <span class="c1"># Poisson parameters for CDC solution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poisson</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;poisson&#39;</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_poisson</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_poisson&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_poisson</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min_poisson&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transition_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">dc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basic_cdc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates gaussian transition pdf</span>

<span class="sd">        Evaluates the gaussian transition probability for x and x1</span>

<span class="sd">        Returns</span>
<span class="sd">            float: transition probability</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Gaussian makes transition PDF symmetrical but some parameters can be</span>
        <span class="c1"># truncated parameters (gamma,delta,h,sigma)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc</span>
            <span class="k">if</span> <span class="n">basic_cdc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">basic_cdc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_cdc</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dc</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">basic_cdc</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_gamma</span><span class="p">:</span>
                    <span class="n">_numerator</span> <span class="o">=</span> <span class="n">gaussian_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">])</span>
                    <span class="n">_denominator</span> <span class="o">=</span> <span class="n">gaussian_cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">])</span><span class="o">-</span><span class="n">gaussian_cdf</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">])</span>
                    <span class="n">p</span> <span class="o">*=</span> <span class="n">_numerator</span><span class="o">/</span><span class="n">_denominator</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_delta</span><span class="p">:</span>
                    <span class="n">_numerator</span> <span class="o">=</span> <span class="n">gaussian_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">])</span>
                    <span class="n">_denominator</span> <span class="o">=</span> <span class="n">gaussian_cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">])</span><span class="o">-</span><span class="n">gaussian_cdf</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">])</span>
                    <span class="n">p</span> <span class="o">*=</span> <span class="n">_numerator</span><span class="o">/</span><span class="n">_denominator</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_cdc</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_alpha</span><span class="p">:</span>
                <span class="c1"># alpha is opening angle as parameter</span>
                <span class="n">_numerator</span> <span class="o">=</span> <span class="n">gaussian_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">])</span>
                <span class="n">_denominator</span> <span class="o">=</span> <span class="n">gaussian_cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">])</span><span class="o">-</span><span class="n">gaussian_cdf</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">])</span>
                <span class="n">p</span> <span class="o">*=</span> <span class="n">_numerator</span><span class="o">/</span><span class="n">_denominator</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_dip</span><span class="p">:</span>
                <span class="n">_numerator</span> <span class="o">=</span> <span class="n">gaussian_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">])</span>
                <span class="n">_denominator</span> <span class="o">=</span> <span class="n">gaussian_cdf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">])</span><span class="o">-</span><span class="n">gaussian_cdf</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">])</span>
                <span class="n">p</span> <span class="o">*=</span> <span class="n">_numerator</span><span class="o">/</span><span class="n">_denominator</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_sigma</span><span class="p">:</span>
                <span class="n">_numerator</span> <span class="o">=</span> <span class="n">gaussian_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">])</span>
                <span class="n">_denominator</span> <span class="o">=</span> <span class="n">gaussian_cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">])</span><span class="o">-</span><span class="n">gaussian_cdf</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">])</span>
                <span class="n">p</span> <span class="o">*=</span> <span class="n">_numerator</span><span class="o">/</span><span class="n">_denominator</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_new_sample_single</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates new sample</span>

<span class="sd">        Generates a new sample by drawing a new sample from the gaussian transition pdf, conditional on the previous sample.</span>

<span class="sd">        Returns</span>
<span class="sd">            New sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_cdc</span><span class="p">:</span>
            <span class="n">xi_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]))</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">xi_alpha</span>
            <span class="k">while</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="ow">or</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_alpha</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
                        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">a</span>
                    <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="n">a</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">xi_alpha</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">poisson</span><span class="p">:</span>
                <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">basic_cdc_GD</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">poisson</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tanphi</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]))</span>
                <span class="n">xi_poisson</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">tanphi</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">tanphi</span><span class="p">)</span>
                <span class="c1"># handle sampling for poisson</span>
                <span class="n">poisson</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;poisson&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">xi_poisson</span>
                <span class="k">while</span> <span class="n">poisson</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_poisson</span> <span class="ow">or</span> <span class="n">poisson</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_poisson</span><span class="p">:</span>
                    <span class="n">poisson</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;poisson&#39;</span><span class="p">]</span> <span class="o">*</span> \
                        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">xi_poisson</span>
                <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">basic_cdc_GD</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">poisson</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_gamma</span><span class="p">:</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span>
            <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_delta</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span>
            <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
        <span class="c1"># since strike 2*pi=strike 0 wrap round</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;kappa&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;kappa&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;kappa&#39;</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># wrap h round and change strike by pi</span>
            <span class="c1"># h&lt;0 slip changes</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_dip</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">h</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># no wrap -redraw</span>
                <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">]</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span>
        <span class="c1"># tape parameterisation limits s to -pi/2 to pi/2</span>
        <span class="c1"># This parameterisation does not wrap in this range - wraps over 2*pi</span>
        <span class="c1"># can however wrap sdr to other sdr pair that have rake in valid sigma range</span>
        <span class="c1">#</span>
        <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_sigma</span><span class="p">:</span>
                <span class="c1"># If trying to wrap would be</span>
                <span class="c1"># [k,d,s]=SDR_SDR(x[&#39;kappa&#39;],np.arccos(x[&#39;h&#39;]),s)</span>
                <span class="c1"># x[&#39;kappa&#39;]=k</span>
                <span class="c1"># x[&#39;h&#39;]=np.cos(d)</span>
                <span class="c1"># alternativly can reflect the PDF instead</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">s</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">+</span><span class="n">s</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">new_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates new sample</span>

<span class="sd">        Can handle multiple events</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">all_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">all_x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expect self.xi to be list not </span><span class="si">{}</span><span class="se">\n</span><span class="s1"> self.xi = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">))</span>
            <span class="n">all_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">all_x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">all_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="n">all_x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_x</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">all_alpha</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new_sample_single</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="o">=</span> <span class="n">all_x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">all_alpha</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_sample_single</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_dc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if a sample x is double-couple&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span>

    <span class="k">def</span> <span class="nf">_convert_sample_single</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts sample to and from tape parameterisation</span>

<span class="sd">        Args</span>
<span class="sd">            x: sample - can be a dict of Tape params -&gt; converted to MT or an MT -&gt; converted to a dict of Tape params</span>

<span class="sd">        Returns</span>
<span class="sd">            Converted Sample</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;gamma&#39;</span><span class="p">,</span> <span class="s1">&#39;delta&#39;</span><span class="p">,</span> <span class="s1">&#39;kappa&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span><span class="p">],</span> <span class="n">MT6_Tape</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">cmarkov_chain_monte_carlo</span><span class="p">:</span>
            <span class="c1"># Try c functions (quicker)</span>
            <span class="k">return</span> <span class="n">cmarkov_chain_monte_carlo</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;kappa&#39;</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">C_EXTENSION_FALLBACK_LOG_MSG</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">MT33_MT6</span><span class="p">(</span><span class="n">Tape_MT33</span><span class="p">(</span><span class="o">**</span><span class="n">x</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_6sphere_random_mt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a random MT</span>

<span class="sd">        Generates a random MT using flat pdfs for each parameter.</span>

<span class="sd">        Returns</span>
<span class="sd">            Random MT in Tape parameterisation</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;kappa&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">random_dc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a random DC</span>

<span class="sd">        Generates a random DC using flat pdfs for each parameter (gamma=delta=0).</span>

<span class="sd">        Returns</span>
<span class="sd">            Random MT in Tape parameterisation</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;kappa&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">random_basic_cdc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a random C+DC</span>

<span class="sd">        Generates a random C+DC using flat pdfs for each parameter (gamma,delta given by alpha).</span>

<span class="sd">        Returns</span>
<span class="sd">            Random MT in Tape parameterisation</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">basic_cdc_GD</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">poisson</span><span class="p">)</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;kappa&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">prior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basic_cdc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates prior probability for x</span>

<span class="sd">        Returns</span>
<span class="sd">            float: prior probability</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">basic_cdc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">basic_cdc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_cdc</span>
        <span class="n">max_poisson</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_poisson</span>
        <span class="n">min_poisson</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_poisson</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">MarginalisedMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">basic_cdc</span><span class="p">,</span> <span class="n">max_poisson</span><span class="p">,</span> <span class="n">min_poisson</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">IterativeMetropolisHastingsGaussianTape</span><span class="p">(</span><span class="n">MarginalisedMetropolisHastingsGaussianTape</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Metropolis-Hastings Markov chain Monte Carlo Algorithm using Gaussian Transition PDF and Tape parameterisation, chain length ends maximum length</span>

<span class="sd">    Algorithm ends when the number of samples in the chain equals the chain_length, where the chain length corresponds to the number of accepted samples.</span>
<span class="sd">    The parameterisation is from Tape and Tape (A geometric setting for moment tensors, Tape and Tape, 2012, GJI 190 pp 476-490).</span>

<span class="sd">    This is a child class of the MarginalisedMetropolisHastingsGaussianTape class</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialisation of Metropolis-Hastings Markov chain Monte Carlo Algorithm using Gaussian Transition PDF and Tape parameterisation, constrained by chain length</span>

<span class="sd">        The chain length corresponds to the number of accepted samples.</span>

<span class="sd">        Keyword Args</span>
<span class="sd">            chain_length:[1000000] Maximum length of the Markov chain.</span>

<span class="sd">        This is a child class of the MarginalisedMetropolisHastingsGaussianTape class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IterativeMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chain_length</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;chain_length&#39;</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iterate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate from result</span>

<span class="sd">        Args</span>
<span class="sd">            result: Result dictionary from forward task (e.g. MTfit.inversion.ForwardTask)</span>

<span class="sd">        Returns</span>
<span class="sd">            new_sample,End where End is a boolean flag to end the chain if the length of accepted samples is longer than the chain length.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">task</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">IterativeMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">iterate</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="c1"># Check chain length</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tried</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_length</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Chain complete</span><span class="se">\n</span><span class="s1">Chain elapsed time: </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_t1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">task</span><span class="p">,</span> <span class="n">end</span>


<span class="k">class</span> <span class="nc">IterativeTransDMetropolisHastingsGaussianTape</span><span class="p">(</span><span class="n">IterativeMetropolisHastingsGaussianTape</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trans-Dimensional Metropolis-Hastings Markov chain Monte Carlo Algorithm using Gaussian Transition PDF and Tape parameterisation, chain length ends maximum length</span>

<span class="sd">    Trans Dimensional sampling, jumping between double-couple and full moment tensor models.</span>
<span class="sd">    Algorithm ends when the number of samples in the chain equals the chain_length, where the chain length corresponds to the number of accepted samples.</span>
<span class="sd">    The parameterisation is from Tape and Tape (A geometric setting for moment tensors, Tape and Tape, 2012, GJI 190 pp 476-490).</span>

<span class="sd">    This is a child class of the IterativeMetropolisHastingsGaussianTape</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialisation of Trans-Dimensional Metropolis-Hastings Markov chain Monte Carlo Algorithm using Gaussian Transition PDF and Tape parameterisation, chain length ends maximum length</span>

<span class="sd">        Keyword Args</span>
<span class="sd">            dimension_jump_prob:[0.01] Probability of making a dimension jump.</span>
<span class="sd">            dc_sigma_g:[0.2] alpha parameter for the balance vector gamma parameter</span>
<span class="sd">            dc_sigma_d:[0.2] alpha parameter for the balance vector delta parameter</span>
<span class="sd">            dc_prior:[0.5] prior probability for the DC model</span>

<span class="sd">        This is a child class of the IterativeMetropolisHastingsGaussianTape</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IterativeTransDMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Update alpha with dc balance vector parameters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;gamma_dc&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">alpha</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;gamma_dc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dc_sigma_g&#39;</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;delta_dc&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">alpha</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;delta_dc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dc_sigma_d&#39;</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;gamma_dc&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;gamma_dc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dc_sigma_g&#39;</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;delta_dc&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;delta_dc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dc_sigma_d&#39;</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Set DC model prior</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dc_prior</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dc_prior&#39;</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">)</span>
        <span class="c1"># Calculate balance vector proposal normalisation</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
        <span class="n">pn</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">*</span><span class="n">gaussian_pdf</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dc_sigma_d&#39;</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span>
                 <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">d</span><span class="p">)))</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">gaussian_cdf</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dc_sigma_g&#39;</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">)))</span>
        <span class="c1"># Add proposal normalisation to alpha</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">:</span>
                <span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;proposal_normalisation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pn</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;proposal_normalisation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pn</span>
        <span class="c1"># Set jump options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension_jump_prob</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dimension_jump_prob&#39;</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_jump_params</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gaussian_jump_params&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_learning_dc_dc_accepted</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_learning_mt_mt_accepted</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_new_sample_single</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates new sample</span>

<span class="sd">        Generates a new sample by drawing a new sample from the gaussian transition pdf, conditional on the previous sample.</span>
<span class="sd">        Probability if the sample jumping between models given by the dimension_jump_prob kwarg on initialisation.</span>

<span class="sd">        Returns</span>
<span class="sd">            New sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set jump check</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension_jump_prob</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span><span class="p">:</span>
            <span class="c1"># new sample is same parameters but with or without gamma and delta</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">)</span>
            <span class="n">x</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;gamma&#39;</span><span class="p">)</span>
            <span class="n">x</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;delta&#39;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">x</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;g0&#39;</span><span class="p">)</span>
                <span class="n">x</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;d0&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">:</span>  <span class="c1"># dc to mt</span>
                <span class="c1"># set random gamma beta</span>
                <span class="n">gamma</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump_params</span><span class="p">()</span>
                <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gamma</span>
                <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># mt to dc (g0 and d0 set from gamma delta)</span>
                <span class="n">x</span><span class="p">[</span><span class="s1">&#39;g0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span>
                <span class="n">x</span><span class="p">[</span><span class="s1">&#39;d0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span>
                <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span> <span class="o">=</span> <span class="n">x</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Normal new sample</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">IterativeTransDMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_new_sample_single</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">jump_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates dimension jump parameters</span>

<span class="sd">        Calculates either the probabilities of the balancing parameters if x exists, else returns the two balancing parameters.</span>

<span class="sd">        Args</span>
<span class="sd">            x:[False] Can be given as the two balancing parameters</span>

<span class="sd">        Returns</span>
<span class="sd">            if x is not  False:</span>
<span class="sd">                float: q - probability of balancing parameters</span>
<span class="sd">            else:</span>
<span class="sd">                float: gamma - Randomly distributed gamma value</span>
<span class="sd">                float: delta - Randomly distributed delta value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If x is passed then this function returns the probability of</span>
        <span class="c1"># obtaining the two balance paraemters</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_jump_params</span><span class="p">:</span>
                <span class="c1"># corresponds to two normal pdfs about 0,0 with widths given by</span>
                <span class="c1"># sigma normalised over the lune</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">gaussian_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;gamma_dc&#39;</span><span class="p">])</span>
                <span class="n">q</span> <span class="o">*=</span> <span class="n">gaussian_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;delta_dc&#39;</span><span class="p">])</span>
                <span class="n">q</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;proposal_normalisation&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="mi">3</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>  <span class="c1"># Scaled uniform prob</span>
            <span class="k">return</span> <span class="n">q</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get jump params</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_jump_params</span><span class="p">:</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="c1"># Not wrapped/reflected</span>
                <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="p">:</span>
                    <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;gamma_dc&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">()</span>
                <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;delta_dc&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
            <span class="k">return</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">delta</span>

    <span class="k">def</span> <span class="nf">acceptance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ln_likelihoodx</span><span class="p">,</span> <span class="n">dc_prior</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates acceptance</span>

<span class="sd">        Calculates the acceptance from the Trans-Dimensional Metropolis condition.</span>

<span class="sd">        Args</span>
<span class="sd">            x: Model values</span>
<span class="sd">            ln_likelihoodx: Model likelihood.</span>

<span class="sd">        Returns</span>
<span class="sd">            float:acceptance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">)</span>
        <span class="c1"># Handle jump parameters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">):</span>
            <span class="c1"># No jump - may have been accidentally picked up</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">IterativeTransDMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">acceptance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ln_likelihoodx</span><span class="p">)</span>
            <span class="c1"># dc to mt jump</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">)</span>
                <span class="n">xi</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;gamma&#39;</span><span class="p">)</span>
                <span class="n">xi</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;delta&#39;</span><span class="p">)</span>
                <span class="n">model_prior_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dc_prior</span><span class="p">)</span><span class="o">/</span><span class="n">dc_prior</span>
                <span class="c1"># LnLikelihoods    N.B&gt; self.jump_params(x) called as x</span>
                <span class="c1"># contains gamma delta generated using jump Params</span>
                <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jump_params</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="n">xi</span><span class="p">)))</span><span class="o">*</span><span class="n">model_prior_ratio</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ln_likelihoodx</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>  <span class="c1"># mt to dc jump</span>
                <span class="n">xp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">xp</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;gamma&#39;</span><span class="p">)</span>
                <span class="n">xp</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;delta&#39;</span><span class="p">)</span>
                <span class="n">model_prior_ratio</span> <span class="o">=</span> <span class="n">dc_prior</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dc_prior</span><span class="p">)</span>
                <span class="c1"># LnLikelihoods    N.B&gt; self.jump_params(self.xi) called as</span>
                <span class="c1"># self.xi contains gamma delta generated using jump Params</span>
                <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jump_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="n">xp</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">))</span><span class="o">*</span><span class="n">model_prior_ratio</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ln_likelihoodx</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># no jump may have been accidentally picked up</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">IterativeTransDMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">acceptance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ln_likelihoodx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">IterativeTransDMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">acceptance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ln_likelihoodx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iterate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterates new sample</span>

<span class="sd">        Calculates the acceptance and handles the pDC output</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">MTs</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">IterativeTransDMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">iterate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Print pDC output</span>
        <span class="k">if</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_dc</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Probability of dc: </span><span class="si">{:.6f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_dc</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_sample</span><span class="o">.</span><span class="n">ln_pdf</span><span class="p">))))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_dc</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pdc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_dc</span><span class="p">):</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Event - </span><span class="si">{}</span><span class="s1"> Probability of dc: </span><span class="si">{:.6f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">pdc</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_sample</span><span class="o">.</span><span class="n">ln_pdf</span><span class="p">))))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span><span class="p">:</span>
            <span class="c1"># check current sample</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dc</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">MTs</span><span class="p">,</span> <span class="n">end</span>

    <span class="k">def</span> <span class="nf">output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return output dict</span>

<span class="sd">        Return output dict including pDC value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span><span class="p">,</span> <span class="n">output_string</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">IterativeTransDMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;pDC&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_dc</span>
        <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">output_string</span>


<div class="viewcode-block" id="IterativeMultipleTryMetropolisHastingsGaussianTape"><a class="viewcode-back" href="../../../markov_chain_monte_carlo.html#MTfit.algorithms.markov_chain_monte_carlo.IterativeMultipleTryMetropolisHastingsGaussianTape">[docs]</a><span class="k">class</span> <span class="nc">IterativeMultipleTryMetropolisHastingsGaussianTape</span><span class="p">(</span><span class="n">IterativeMetropolisHastingsGaussianTape</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Metropolis-Hastings Markov chain Monte Carlo Algorithm using Gaussian Transition PDF and Tape parameterisation, chain length ends maximum length</span>

<span class="sd">    Algorithm ends when the number of samples in the chain equals the chain_length, where the chain length corresponds to the number of accepted samples.</span>
<span class="sd">    The parameterisation is from Tape and Tape (A geometric setting for moment tensors, Tape and Tape, 2012, GJI 190 pp 476-490).</span>

<span class="sd">    This is a child class of the IterativeMetropolisHastingsGaussianTape</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialisation of Metropolis-Hastings Markov chain Monte Carlo Algorithm using Gaussian Transition PDF and Tape parameterisation, constrained by chain length</span>

<span class="sd">        The chain length corresponds to the number of accepted samples.</span>

<span class="sd">        Keyword Args</span>
<span class="sd">            number_samples:[1000] Maximum number of samples to try on each iteration. (unused samples are dropped)</span>

<span class="sd">        This is a child class of the IterativeMetropolisHastingsGaussianTape</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IterativeMultipleTryMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_number_samples</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;number_samples&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">min_acceptance_rate</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_number_samples</span><span class="p">)</span>

<div class="viewcode-block" id="IterativeMultipleTryMetropolisHastingsGaussianTape.new_sample"><a class="viewcode-back" href="../../../markov_chain_monte_carlo.html#MTfit.algorithms.markov_chain_monte_carlo.IterativeMultipleTryMetropolisHastingsGaussianTape.new_sample">[docs]</a>    <span class="k">def</span> <span class="nf">new_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">gaussian_jump</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get new samples including multiple samples to try&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cmarkov_chain_monte_carlo</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Try c code</span>
                <span class="c1"># Multiple events</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">mt</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">):</span>
                        <span class="n">xi_1</span><span class="p">,</span> <span class="n">mt_i</span> <span class="o">=</span> <span class="n">cmarkov_chain_monte_carlo</span><span class="o">.</span><span class="n">new_samples</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                                           <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                                           <span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span><span class="p">,</span>
                                                                           <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                                           <span class="n">jump</span><span class="o">=</span><span class="n">jump</span><span class="p">,</span>
                                                                           <span class="n">gaussian_jump</span><span class="o">=</span><span class="n">gaussian_jump</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xi_1</span><span class="p">)</span>
                        <span class="n">mt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mt_i</span><span class="p">)</span>
                <span class="c1"># Single event</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">,</span> <span class="n">mt</span> <span class="o">=</span> <span class="n">cmarkov_chain_monte_carlo</span><span class="o">.</span><span class="n">new_samples</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">,</span>
                                                                          <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                                                                          <span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span><span class="p">,</span>
                                                                          <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">,</span>
                                                                          <span class="n">jump</span><span class="o">=</span><span class="n">jump</span><span class="p">,</span>
                                                                          <span class="n">gaussian_jump</span><span class="o">=</span><span class="n">gaussian_jump</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">mt</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;Cython error&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">C_EXTENSION_FALLBACK_LOG_MSG</span><span class="p">)</span>
        <span class="c1"># Otherwise/Fallback to use python code</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">IterativeMultipleTryMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">new_sample</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_acceptance_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">scale_factori_1</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check acceptance for multiple tries&quot;&quot;&quot;</span>
        <span class="c1"># TODO tidy this code up</span>
        <span class="k">if</span> <span class="n">cmarkov_chain_monte_carlo</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Try C code</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">LnPDF</span><span class="p">):</span>
                    <span class="n">ln_pi_1</span> <span class="o">=</span> <span class="n">ln_pi_1</span><span class="o">.</span><span class="n">_ln_pdf</span>
                <span class="c1"># No non-zero samples</span>
                <span class="k">if</span> <span class="n">ln_pi_1</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                    <span class="n">xi_1</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">ln_pi_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">xi_1</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">)]</span>
                    <span class="n">ln_pi_1</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="c1"># If in learning, increase the number of test samples</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">():</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_number_samples</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span>
                            <span class="nb">int</span><span class="p">(</span><span class="mf">1.1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
                    <span class="k">return</span> <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">index</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="o">.</span><span class="n">major</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">is_uniform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prior</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;uniform_prior&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">is_uniform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prior</span><span class="o">.</span><span class="n">func_name</span> <span class="o">==</span> <span class="s1">&#39;uniform_prior&#39;</span>
                    <span class="c1"># Mutliple events</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;dc_prior&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dc_prior</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">dc_prior</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">dc_prior</span><span class="p">])</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                            <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">cmarkov_chain_monte_carlo</span><span class="o">.</span><span class="n">me_acceptance_check</span><span class="p">(</span><span class="n">xi_1</span><span class="p">,</span>
                                                                                                 <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">,</span>
                                                                                                 <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                                                                                                 <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                                                                                 <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">,</span>
                                                                                                 <span class="n">is_uniform</span><span class="p">,</span>
                                                                                                 <span class="n">gaussian_jump</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;gaussian_jump_params&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                                                                                                 <span class="n">dc_prior</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;dc_prior&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">])))</span>  <span class="c1"># dc prior ignored if not transd</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">cmarkov_chain_monte_carlo</span><span class="o">.</span><span class="n">me_acceptance_check</span><span class="p">(</span><span class="n">xi_1</span><span class="p">,</span>
                                                                                                 <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">,</span>
                                                                                                 <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                                                                                                 <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="o">.</span><span class="n">_ln_pdf</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                                                                                 <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">,</span>
                                                                                                 <span class="n">is_uniform</span><span class="p">,</span>
                                                                                                 <span class="n">gaussian_jump</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;gaussian_jump_params&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                                                                                                 <span class="n">dc_prior</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;dc_prior&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">])))</span>
                    <span class="c1"># Single events</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                            <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">cmarkov_chain_monte_carlo</span><span class="o">.</span><span class="n">acceptance_check</span><span class="p">(</span><span class="n">xi_1</span><span class="p">,</span>
                                                                                              <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">,</span>
                                                                                              <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                                                                                              <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                                                                              <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">,</span>
                                                                                              <span class="n">is_uniform</span><span class="p">,</span>
                                                                                              <span class="n">gaussian_jump</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;gaussian_jump_params&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                                                                                              <span class="n">dc_prior</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;dc_prior&#39;</span><span class="p">,</span> <span class="mf">0.</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">cmarkov_chain_monte_carlo</span><span class="o">.</span><span class="n">acceptance_check</span><span class="p">(</span><span class="n">xi_1</span><span class="p">,</span>
                                                                                              <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">,</span>
                                                                                              <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                                                                                              <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="o">.</span><span class="n">_ln_pdf</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                                                                              <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">,</span>
                                                                                              <span class="n">is_uniform</span><span class="p">,</span>
                                                                                              <span class="n">gaussian_jump</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;gaussian_jump_params&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                                                                                              <span class="n">dc_prior</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;dc_prior&#39;</span><span class="p">,</span> <span class="mf">0.</span><span class="p">))</span>
                <span class="c1"># No accepted samples, so increase the number of test samples if in</span>
                <span class="c1"># learning period</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_number_samples</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mf">1.1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">min</span><span class="p">([</span><span class="mi">120</span><span class="o">*</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span><span class="p">)])</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span><span class="p">:</span>
                    <span class="c1"># Handle too many samples</span>
                    <span class="c1"># Probability of having accepted sample within index is</span>
                    <span class="c1">#</span>
                    <span class="c1">#   P(x&lt;=j)=1-(1-r)^j</span>
                    <span class="c1">#</span>
                    <span class="c1"># where r is the probability of accepting a sample and j is the accepted sample index</span>
                    <span class="c1"># Solving for this given r~1/number_samples for P=0.01 gives j~0.01*number_samples</span>
                    <span class="c1"># Consequently, the index of the accepted sample has a probability of 0.01 of being &lt; 0.01*number_samples (given the number_samples -&gt; r estimate)</span>
                    <span class="c1"># The factor of 120 is a fudge to account for uncertainties</span>
                    <span class="c1"># (this can help prevent calculating too many forward models)</span>
                    <span class="c1"># max prevents 0 for _number_samples</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="mi">120</span><span class="o">*</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span><span class="p">)])</span>
                <span class="c1"># Accepted sample with scale_factor (relative inversion)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale_factori_1</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">scale_factori_1</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">index</span>
                <span class="k">return</span> <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">index</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;Cython Error&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">C_EXTENSION_FALLBACK_LOG_MSG</span><span class="p">)</span>
        <span class="c1"># Otherwise use/fallback to Python code</span>
        <span class="c1"># Non-zero samples</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">ln_pi_1</span> <span class="o">=</span> <span class="n">ln_pi_1</span><span class="o">.</span><span class="n">_ln_pdf</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="c1"># Loop over samples</span>
            <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">_xi_1</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xi_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">):</span>
                            <span class="n">_xi_1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xi_1</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">_xi_1</span> <span class="o">=</span> <span class="n">xi_1</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xi_1</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">_xi_1</span> <span class="o">=</span> <span class="n">xi_1</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">_xi_1</span> <span class="o">=</span> <span class="n">xi_1</span>
                <span class="c1"># Get acceptance result</span>
                <span class="n">oxi_1</span><span class="p">,</span> <span class="n">oln_pi_1</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">IterativeMultipleTryMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_acceptance_check</span><span class="p">(</span><span class="n">_xi_1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">u</span><span class="p">],</span>
                                                                                                                          <span class="kc">False</span><span class="p">,</span> <span class="n">dc_prior</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;dc_prior&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">oln_pi_1</span><span class="p">:</span>
                    <span class="c1"># If accepted sample, try to get the sacale_factor</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale_factori_1</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                        <span class="n">oscale_factori_1</span> <span class="o">=</span> <span class="n">scale_factori_1</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">oscale_factori_1</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">return</span> <span class="n">oxi_1</span><span class="p">,</span> <span class="n">oln_pi_1</span><span class="p">,</span> <span class="n">oscale_factori_1</span><span class="p">,</span> <span class="n">u</span>
            <span class="c1"># No Accepted samples</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">tried</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tried</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">return</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">)],</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">tried</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">tried</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tried</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{},</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">tried</span>
        <span class="c1"># No accepted samples</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">tried</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tried</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">return</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">)],</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">tried</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">tried</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tried</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{},</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">tried</span>
        <span class="k">elif</span> <span class="n">ln_pi_1</span> <span class="o">==</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                        <span class="n">tried</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tried</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">return</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">)],</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">tried</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">tried</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tried</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{},</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">tried</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">dc</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dc</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">IterativeMultipleTryMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_acceptance_check</span><span class="p">(</span><span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">scale_factori_1</span><span class="p">,</span> <span class="n">dc_prior</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;dc_prior&#39;</span><span class="p">,</span> <span class="n">dc</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_modify_acceptance_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">non_zero_percentage</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjusts the acceptance rate parameters based on the targetted acceptance rate.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IterativeMultipleTryMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_modify_acceptance_rate</span><span class="p">(</span><span class="n">non_zero_percentage</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">min_acceptance_rate</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_number_samples</span><span class="p">)</span></div>


<div class="viewcode-block" id="IterativeMultipleTryTransDMetropolisHastingsGaussianTape"><a class="viewcode-back" href="../../../markov_chain_monte_carlo.html#MTfit.algorithms.markov_chain_monte_carlo.IterativeMultipleTryTransDMetropolisHastingsGaussianTape">[docs]</a><span class="k">class</span> <span class="nc">IterativeMultipleTryTransDMetropolisHastingsGaussianTape</span><span class="p">(</span><span class="n">IterativeTransDMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="n">IterativeMultipleTryMetropolisHastingsGaussianTape</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trans-Dimensional Metropolis-Hastings Markov chain Monte Carlo Algorithm using Gaussian Transition PDF and Tape parameterisation, chain length ends maximum length</span>

<span class="sd">    Trans Dimensional sampling, jumping between double-couple and full moment tensor models.</span>
<span class="sd">    Algorithm ends when the number of samples in the chain equals the chain_length, where the chain length corresponds to the number of accepted samples.</span>
<span class="sd">    The parameterisation is from Tape and Tape (A geometric setting for moment tensors, Tape and Tape, 2012, GJI 190 pp 476-490).</span>

<span class="sd">    This is a child class of both the IterativeTransDMetropolisHastingsGaussianTape and IterativeMultipleTryMetropolisHastingsGaussianTape</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialisation of Trans-Dimensional Metropolis-Hastings Markov chain Monte Carlo Algorithm using Gaussian Transition PDF and Tape parameterisation, chain length ends maximum length</span>


<span class="sd">        This is a child class of both the IterativeTransDMetropolisHastingsGaussianTape and IterativeMultipleTryMetropolisHastingsGaussianTape</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IterativeMultipleTryTransDMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="IterativeMultipleTryTransDMetropolisHastingsGaussianTape.new_sample"><a class="viewcode-back" href="../../../markov_chain_monte_carlo.html#MTfit.algorithms.markov_chain_monte_carlo.IterativeMultipleTryTransDMetropolisHastingsGaussianTape.new_sample">[docs]</a>    <span class="k">def</span> <span class="nf">new_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates new sample</span>

<span class="sd">        Generates a new sample by drawing a new sample from the gaussian transition pdf, conditional on the previous sample.</span>
<span class="sd">        Probability if the sample jumping between models given by the dimension_jump_prob kwarg on initialisation.</span>

<span class="sd">        Returns</span>
<span class="sd">            New sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IterativeMultipleTryMetropolisHastingsGaussianTape</span><span class="o">.</span><span class="n">new_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension_jump_prob</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_jump_params</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, David Pugh.
      Last updated on Aug 29, 2018 (version 1.0.3a12).

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1.0.3a12',
            LANGUAGE:'English',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>