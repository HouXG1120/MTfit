

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="English" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="English" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>5. Tutorial: Using MTfit with Real Data &mdash; MTfit documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/style.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="6. Bayesian Approach" href="bayes.html" />
    <link rel="prev" title="4. Tutorial: Using MTfit" href="tutorial.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> MTfit
          

          
            
            <img src="_static/MTfitsphinx.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                1.0.3a12
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="setup.html">2. Installing</a></li>
<li class="toctree-l1"><a class="reference internal" href="run.html">3. Running MTfit</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">4. Tutorial</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">5. Tutorial: Real Data Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#synthetic-event">5.1. Synthetic Event</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#synthetic-p-polarity-inversion">5.1.1. Synthetic P Polarity Inversion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#synthetic-polarity-and-amplitude-ratio-inversion">5.1.2. Synthetic Polarity and Amplitude Ratio Inversion</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#krafla-event">5.2. Krafla Event</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#krafla-p-polarity-inversion">5.2.1. Krafla P Polarity Inversion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#krafla-p-polarity-probability-inversion">5.2.2. Krafla P Polarity Probability Inversion</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#bayesian-evidence">5.3. Bayesian Evidence</a></li>
<li class="toctree-l2"><a class="reference internal" href="#joint-inversion">5.4. Joint Inversion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="bayes.html">6. Bayesian Approach</a></li>
<li class="toctree-l1"><a class="reference internal" href="probability.html">7. Probability Density Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="algorithms.html">8. Search Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="mtconvert.html">9. Moment Tensor Conversion</a></li>
<li class="toctree-l1"><a class="reference internal" href="cli.html">10. Command Line Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="mtplot.html">11. Plotting</a></li>
<li class="toctree-l1"><a class="reference internal" href="plot_classes.html">1. Plot Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="mtplotcli.html">12. MTplot Command Line Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="inversion.html">13. Inversion Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="extensions.html">14. Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="references.html">15. References</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">2. Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="source.html">3. Source Code</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/djpugh/MTfit">GitHub Repository</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MTfit</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>5. Tutorial: Using MTfit with Real Data</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/real-tutorial.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="tutorial-using-mtfit-with-real-data">
<h1>5. Tutorial: Using MTfit with Real Data<a class="headerlink" href="#tutorial-using-mtfit-with-real-data" title="Permalink to this headline">¶</a></h1>
<p>The <a class="reference internal" href="tutorial.html"><span class="doc">previous</span></a> section has introduced many of the different options available in <code class="xref py py-mod docutils literal notranslate"><span class="pre">MTfit</span></code>. This section explains the reasoning behind the choice of these parameters using a synthetic and real example.</p>
<p>The tutorials described here are:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#synthetic-p-polarity"><span class="std std-ref">Synthetic P Polarity Inversion</span></a> - Inversion of synthetic P polarity data using Monte Carlo sampling.</li>
<li><a class="reference internal" href="#synthetic-ar"><span class="std std-ref">Synthetic Polarity and Amplitude Ratio Inversion</span></a> - Inversion of synthetic P polarity and P/SH amplitude ratio data using Monte Carlo sampling.</li>
<li><a class="reference internal" href="#real-p-polarity"><span class="std std-ref">Krafla P Polarity Inversion</span></a> - Inversion of real P polarity data using Monte Carlo sampling, including location uncertainty.</li>
<li><a class="reference internal" href="#real-p-polarity-probability"><span class="std std-ref">Krafla P Polarity Probability Inversion</span></a> - Inversion of real P polarity probability data using Markov chain Monte Carlo sampling, including location uncertainty.</li>
<li><a class="reference internal" href="#bayesian-evidence"><span class="std std-ref">Bayesian Evidence</span></a> - Bayesian evidence calculation for the Monte Carlo sampled examples.</li>
<li><a class="reference internal" href="#relative-inversion"><span class="std std-ref">Joint Inversion</span></a> - Joint inversion of synthetic data using P polarities and relative P amplitude ratios using both Monte Carlo and Markov chain Monte Carlo sampling.</li>
</ul>
</div></blockquote>
<div class="section" id="synthetic-event">
<span id="id1"></span><h2>5.1. Synthetic Event<a class="headerlink" href="#synthetic-event" title="Permalink to this headline">¶</a></h2>
<div class="figure align-right" id="id6" style="width: 30%">
<a class="reference internal image-reference" href="_images/synthetic_event.png"><img alt="Beachball plot of the synthetic source" src="_images/synthetic_event.png" style="width: 90%;" /></a>
<p class="caption"><span class="caption-text"><em>Beachball plot of the synthetic source and receiver positions for the location (Plotted using MTplot MATLAB code)</em></span></p>
</div>
<p>The synthetic event shown here has been generated from a double-couple source using a finite difference approach (<a class="reference internal" href="references.html#bernth-2011"><span class="std std-ref">Bernth and Chapman, 2011</span></a>). Gaussian random noise was added to the data, which were manually picked for both P and S arrival times and P polarities, and then located using <a class="reference external" href="http://alomax.free.fr/nlloc">NonLinLoc</a> and a simplified version of the known velocity model. The arrival time picks were used to automatically window and measure P, SH, and SV amplitudes.</p>
<div class="section" id="synthetic-p-polarity-inversion">
<span id="synthetic-p-polarity"></span><h3>5.1.1. Synthetic P Polarity Inversion<a class="headerlink" href="#synthetic-p-polarity-inversion" title="Permalink to this headline">¶</a></h3>
<p>There are 16 P-polarity arrivals for the synthetic event, and the locations of these receivers are shown in the figure to the right. These receivers provide quite good coverage of the focal sphere, although there is not much constraint on the fault planes due to the large spacings between receivers of contrasting polarities.</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">example_data</span> <span class="kn">import</span> <span class="n">synthetic_event</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">=</span><span class="n">synthetic_event</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;PPolarity&#39;</span><span class="p">]</span>
<span class="go">{&#39;Error&#39;: matrix([[0.05],</span>
<span class="go">        [0.05],</span>
<span class="go">        [0.05],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [1.  ],</span>
<span class="go">        [0.01],</span>
<span class="go">        [1.  ],</span>
<span class="go">        [1.  ],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.05],</span>
<span class="go">        [0.05]]), &#39;Measured&#39;: matrix([[-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [ 1],</span>
<span class="go">        [-1],</span>
<span class="go">        [ 1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [ 1],</span>
<span class="go">        [ 1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [ 1],</span>
<span class="go">        [-1],</span>
<span class="go">        [ 1]]), &#39;Stations&#39;: {&#39;Azimuth&#39;: matrix([[ 55.9],</span>
<span class="go">        [ 76.9],</span>
<span class="go">        [277.9],</span>
<span class="go">        [  5.4],</span>
<span class="go">        [224.7],</span>
<span class="go">        [ 31.9],</span>
<span class="go">        [ 47.9],</span>
<span class="go">        [ 45.2],</span>
<span class="go">        [224.6],</span>
<span class="go">        [122.6],</span>
<span class="go">        [328.4],</span>
<span class="go">        [ 45.2],</span>
<span class="go">        [309.3],</span>
<span class="go">        [187.7],</span>
<span class="go">        [ 16.1],</span>
<span class="go">                    [193.4]]), &#39;Name&#39;: [&#39;S0517&#39;, &#39;S0415&#39;, &#39;S0347&#39;, &#39;S0534&#39;, </span>
<span class="go">            &#39;S0244&#39;, &#39;S0618&#39;, &#39;S0650&#39;, &#39;S0595&#39;, &#39;S0271&#39;, &#39;S0155&#39;, &#39;S0529&#39;, </span>
<span class="go">            &#39;S0649&#39;, &#39;S0450&#39;, &#39;S0195&#39;, &#39;S0588&#39;, &#39;S0142&#39;], &#39;TakeOffAngle&#39;: </span>
<span class="go">            matrix([[122.8],</span>
<span class="go">        [120.8],</span>
<span class="go">        [152.4],</span>
<span class="go">        [138.7],</span>
<span class="go">        [149.6],</span>
<span class="go">        [120. ],</span>
<span class="go">        [107.4],</span>
<span class="go">        [117. ],</span>
<span class="go">        [156.4],</span>
<span class="go">        [115.3],</span>
<span class="go">        [133.3],</span>
<span class="go">        [109.1],</span>
<span class="go">        [139.9],</span>
<span class="go">        [147.2],</span>
<span class="go">        [128.7],</span>
<span class="go">        [137.6]])}}</span>
</pre></div>
</div>
</div></blockquote>
<p><a class="reference download internal" href="_downloads/synthetic_event.py" download=""><code class="xref download docutils literal notranslate"><span class="pre">examples/synthetic_event.py</span></code></a> contains a script for the double-couple and full moment tensor inversion of the source. It can be run as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ python synthetic_event.py case=ppolarity
</pre></div>
</div>
<p>Adding a <code class="docutils literal notranslate"><span class="pre">-l</span></code> flag will run the inversion in a single thread.</p>
<p>The important part of the script is:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># print output data</span>
<span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;PPolarity&#39;</span><span class="p">])</span>
<span class="n">data</span><span class="p">[</span><span class="s1">&#39;UID&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;_ppolarity&#39;</span>
<span class="c1"># Set inversion parameters</span>
<span class="c1"># Use an iteration random sampling algorithm</span>
<span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;iterate&#39;</span>
<span class="c1"># Run in parallel if set on command line</span>
<span class="n">parallel</span> <span class="o">=</span> <span class="n">parallel</span>
<span class="c1"># uses a soft memory limit of 1Gb of RAM for estimating the sample sizes</span>
<span class="c1"># (This is only a soft limit, so no errors are thrown if the memory usage</span>
<span class="c1">#       increases above this)</span>
<span class="n">phy_mem</span> <span class="o">=</span> <span class="mi">1</span>
<span class="c1"># Run in double-couple space only</span>
<span class="n">dc</span> <span class="o">=</span> <span class="bp">True</span>
<span class="c1"># Run for one hundred thousand samples</span>
<span class="n">max_samples</span> <span class="o">=</span> <span class="mi">100000</span>
<span class="c1"># Set to only use P Polarity data</span>
<span class="n">inversion_options</span> <span class="o">=</span> <span class="s1">&#39;PPolarity&#39;</span>
<span class="c1"># Set the convert flag to convert the output to other source parameterisations</span>
<span class="n">convert</span> <span class="o">=</span> <span class="bp">True</span>
<span class="c1"># Create the inversion object with the set parameters.</span>
<span class="n">inversion_object</span> <span class="o">=</span> <span class="n">Inversion</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span>
                             <span class="n">inversion_options</span><span class="o">=</span><span class="n">inversion_options</span><span class="p">,</span> <span class="n">phy_mem</span><span class="o">=</span><span class="n">phy_mem</span><span class="p">,</span> <span class="n">dc</span><span class="o">=</span><span class="n">dc</span><span class="p">,</span>
                             <span class="n">max_samples</span><span class="o">=</span><span class="n">max_samples</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="n">convert</span><span class="p">)</span>
<span class="c1"># Run the forward model</span>
<span class="n">inversion_object</span><span class="o">.</span><span class="n">forward</span><span class="p">()</span>
<span class="c1"># Run the full moment tensor inversion</span>
<span class="c1"># Increase the max samples due to the larger source space to 10 million samples</span>
<span class="n">max_samples</span> <span class="o">=</span> <span class="mi">10000000</span>
<span class="c1"># Create the inversion object with the set parameters.</span>
<span class="n">inversion_object</span> <span class="o">=</span> <span class="n">Inversion</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span>
                             <span class="n">inversion_options</span><span class="o">=</span><span class="n">inversion_options</span><span class="p">,</span> <span class="n">phy_mem</span><span class="o">=</span><span class="n">phy_mem</span><span class="p">,</span> <span class="n">dc</span><span class="o">=</span><span class="ow">not</span> <span class="n">dc</span><span class="p">,</span>
                             <span class="n">max_samples</span><span class="o">=</span><span class="n">max_samples</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="n">convert</span><span class="p">)</span>
<span class="c1"># Run the forward model</span>
<span class="n">inversion_object</span><span class="o">.</span><span class="n">forward</span><span class="p">()</span>
<span class="c1"># Equivalent to pickling the data:</span>
<span class="c1">#  &gt;&gt;&gt; from example_data import synthetic_event</span>
<span class="c1">#  &gt;&gt;&gt; data=synthetic_event()</span>
<span class="c1">#  &gt;&gt;&gt; import cPickle</span>
<span class="c1">#  &gt;&gt;&gt; cPickle.dump(data,open(&#39;synthetic_event_data.inv&#39;,&#39;wb&#39;))</span>
<span class="c1"># And then calling from the command line</span>
<span class="c1">#  MTfit --algorithm=iterate --pmem=1 --double-couple --max-samples=100000 \</span>
<span class="c1">#    --inversion-options=PPolarity --convert synthetic_event_data.inv</span>
<span class="c1">#  MTfit --algorithm=iterate --pmem=1 --max-samples=10000000  \</span>
<span class="c1">#    --inversion-options=PPolarity --convert synthetic_event_data.inv</span>
</pre></div>
</div>
</div></blockquote>
<p>The chosen algorithm is the <code class="docutils literal notranslate"><span class="pre">iterate</span></code> algorithm (see <a class="reference internal" href="algorithms.html#mcsampling"><span class="std std-ref">Random Monte Carlo sampling</span></a>) for <code class="docutils literal notranslate"><span class="pre">100</span> <span class="pre">000</span></code> samples for the double-couple case and <code class="docutils literal notranslate"><span class="pre">10</span> <span class="pre">000</span> <span class="pre">000</span></code> for the full moment tensor inversion.
<code class="docutils literal notranslate"><span class="pre">100</span> <span class="pre">000</span></code> samples in the double-couple space corresponds to approximately <code class="docutils literal notranslate"><span class="pre">50</span></code> samples in each parameter (strike, dip cosine, and rake).
While this more dense samplings are possible, this produces a good sampling of the posterior PDF quickly, especially when run in parallel.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If running this in parallel on a server, be aware that because the number of workers option <code class="docutils literal notranslate"><span class="pre">number_workers</span></code> is not set, as many processes as processors will be spawned, slowing down the machine for any other users.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">10</span> <span class="pre">000</span> <span class="pre">000</span></code> samples for the full moment tensor inversion may seem like a coarse sampling, however, due to the higher noise level and the use of P polarity data only, there is much less constraint on the full moment tensor source PDF so this sampling still provides a good approximation of the results.</p>
<p>This script is equivalent to pickling the data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">example_data</span> <span class="k">import</span> <span class="n">synthetic_event</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">=</span><span class="n">synthetic_event</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cPickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;synthetic_event_data.inv&#39;</span><span class="p">,</span><span class="s1">&#39;wb&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>And then calling from the command line (Assuming parallel running: <code class="docutils literal notranslate"><span class="pre">-l</span></code> flag to run on a single processor):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ MTfit --algorithm=iterate --pmem=1 --double-couple --max-samples=100000 \
    --inversion-options=PPolarity --convert synthetic_event_data.inv
$ MTfit --algorithm=iterate --pmem=1 --max-samples=10000000  \
    --inversion-options=PPolarity --convert synthetic_event_data.inv
</pre></div>
</div>
<p>These inversions should not take long to run (running on a single core of an i5 processor, the two inversions take 2 and 72 seconds respectively), although the conversions using <code class="xref py py-mod docutils literal notranslate"><span class="pre">MTfit.MTconvert</span></code> can add to this time, but will reduce the time when plotting the results. The solutions are outputted as a MATLAB file for the DC and MT solutions respectively, with name <code class="docutils literal notranslate"><span class="pre">synthetic_example_event_ppolarityDC.mat</span></code> and <code class="docutils literal notranslate"><span class="pre">synthetic_example_event_ppolarityMT.mat</span></code> respectively.</p>
<div class="figure align-center" id="id8" style="width: 70%">
<span id="synthetic-event-p-polarity-fig"></span><a class="reference internal image-reference" href="_images/synthetic_event_p_polarity.png"><img alt="Beachball plot showing the fault plane orientations for the double-couple constrained inversion and the marginalised source-type PDF for the full moment tensor inversion of the synthetic data." src="_images/synthetic_event_p_polarity.png" style="width: 90%;" /></a>
<p class="caption"><span class="caption-text"><em>Beachball plot showing the fault plane orientations for the double-couple constrained inversion and the marginalised source-type PDF for the full moment tensor inversion of the synthetic data using polarities(Plotted using MTplot MATLAB code).</em></span></p>
</div>
</div>
<div class="section" id="synthetic-polarity-and-amplitude-ratio-inversion">
<span id="synthetic-ar"></span><h3>5.1.2. Synthetic Polarity and Amplitude Ratio Inversion<a class="headerlink" href="#synthetic-polarity-and-amplitude-ratio-inversion" title="Permalink to this headline">¶</a></h3>
<p>Including amplitude ratios (<code class="docutils literal notranslate"><span class="pre">P/SH</span></code> and <code class="docutils literal notranslate"><span class="pre">P/SV</span></code>) in the inversion can improve the source constraint, but, as shown in <a class="reference internal" href="references.html#pugh-2016a"><span class="std std-ref">Pugh et al. 2016a</span></a>, the amplitude ratio can include a systematic error that is dependent on the noise level, leading to deviations from the &quot;True&quot; source.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Amplitudes and amplitude ratios can show systematic deviations from the &quot;True&quot; value due to the noise and the method of measuring the amplitudes. Consequently, care must be taken when using amplitude ratio data in the source inversion, including tests to see if the different amplitude ratios are consistent with each other and the polarity only inversion.</p>
</div>
<p>These tests are ignored in this example, but can lead to very sparse solutions in the source inversion.</p>
<p><a class="reference download internal" href="_downloads/synthetic_event.py" download=""><code class="xref download docutils literal notranslate"><span class="pre">examples/synthetic_event.py</span></code></a> contains a script for the double-couple and full moment tensor inversion of the source. It can be run as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ python synthetic_event.py case=ar
</pre></div>
</div>
<p>Adding a <code class="docutils literal notranslate"><span class="pre">-l</span></code> flag will run the inversion in a single thread.</p>
<p>The important part of the script is:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># print output data</span>
<span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;PPolarity&#39;</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;P/SHRMSAmplitudeRatio&#39;</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;P/SVRMSAmplitudeRatio&#39;</span><span class="p">])</span>
<span class="n">data</span><span class="p">[</span><span class="s1">&#39;UID&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;_ar&#39;</span>
<span class="c1"># Set inversion parameters</span>
<span class="c1"># Use an iteration random sampling algorithm</span>
<span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;iterate&#39;</span>
<span class="c1"># Run in parallel if set on command line</span>
<span class="n">parallel</span> <span class="o">=</span> <span class="n">parallel</span>
<span class="c1"># uses a soft memory limit of 1Gb of RAM for estimating the sample sizes</span>
<span class="c1"># (This is only a soft limit, so no errors are thrown if the memory usage</span>
<span class="c1">#     increases above this)</span>
<span class="n">phy_mem</span> <span class="o">=</span> <span class="mi">1</span>
<span class="c1"># Run in double-couple space only</span>
<span class="n">dc</span> <span class="o">=</span> <span class="bp">True</span>
<span class="c1"># Run for one hundred thousand samples</span>
<span class="n">max_samples</span> <span class="o">=</span> <span class="mi">100000</span>
<span class="c1"># Set to only use P Polarity data</span>
<span class="n">inversion_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;PPolarity&#39;</span><span class="p">,</span> <span class="s1">&#39;P/SHRMSAmplitudeRatio&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;P/SVRMSAmplitudeRatio&#39;</span><span class="p">]</span>
<span class="c1"># Set the convert flag to convert the output to other source parameterisations</span>
<span class="n">convert</span> <span class="o">=</span> <span class="bp">False</span>
<span class="c1"># Create the inversion object with the set parameters.</span>
<span class="n">inversion_object</span> <span class="o">=</span> <span class="n">Inversion</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span>
                             <span class="n">inversion_options</span><span class="o">=</span><span class="n">inversion_options</span><span class="p">,</span> <span class="n">phy_mem</span><span class="o">=</span><span class="n">phy_mem</span><span class="p">,</span> <span class="n">dc</span><span class="o">=</span><span class="n">dc</span><span class="p">,</span>
                             <span class="n">max_samples</span><span class="o">=</span><span class="n">max_samples</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="n">convert</span><span class="p">)</span>
<span class="c1"># Run the forward model</span>
<span class="n">inversion_object</span><span class="o">.</span><span class="n">forward</span><span class="p">()</span>
<span class="c1"># Run the full moment tensor inversion</span>
<span class="c1"># Increase the max samples due to the larger source space to 50 million samples</span>
<span class="n">max_samples</span> <span class="o">=</span> <span class="mi">50000000</span>
<span class="c1"># Create the inversion object with the set parameters.</span>
<span class="n">inversion_object</span> <span class="o">=</span> <span class="n">Inversion</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span>
                             <span class="n">inversion_options</span><span class="o">=</span><span class="n">inversion_options</span><span class="p">,</span> <span class="n">phy_mem</span><span class="o">=</span><span class="n">phy_mem</span><span class="p">,</span> <span class="n">dc</span><span class="o">=</span><span class="ow">not</span> <span class="n">dc</span><span class="p">,</span>
                             <span class="n">max_samples</span><span class="o">=</span><span class="n">max_samples</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="n">convert</span><span class="p">)</span>
<span class="c1"># Run the forward model</span>
<span class="n">inversion_object</span><span class="o">.</span><span class="n">forward</span><span class="p">()</span>
<span class="c1"># Equivalent to pickling the data:</span>
<span class="c1">#  &gt;&gt;&gt; from example_data import synthetic_event</span>
<span class="c1">#  &gt;&gt;&gt; data=synthetic_event()</span>
<span class="c1">#  &gt;&gt;&gt; import cPickle</span>
<span class="c1">#  &gt;&gt;&gt; cPickle.dump(data,open(&#39;synthetic_event_data.inv&#39;,&#39;wb&#39;))</span>
<span class="c1"># And then calling from the command line</span>
<span class="c1">#  MTfit --algorithm=iterate --pmem=1 --double-couple --max-samples=100000 \</span>
<span class="c1">#    --inversion-options=PPolarity,P/SHRMSAmplitudeRatio,P/SVRMSAmplitudeRatio \</span>
<span class="c1">#    --convert synthetic_event_data.inv</span>
<span class="c1">#  MTfit --algorithm=iterate --pmem=1 --max-samples=50000000  \</span>
<span class="c1">#    --inversion-options=PPolarity,P/SHRMSAmplitudeRatio,P/SVRMSAmplitudeRatio \</span>
<span class="c1">#    --convert synthetic_event_data.inv</span>
</pre></div>
</div>
</div></blockquote>
<p>The chosen algorithm is the <code class="docutils literal notranslate"><span class="pre">iterate</span></code> algorithm (see <a class="reference internal" href="algorithms.html#mcsampling"><span class="std std-ref">Random Monte Carlo sampling</span></a>) for <code class="docutils literal notranslate"><span class="pre">100</span> <span class="pre">000</span></code> samples for the double-couple case and <code class="docutils literal notranslate"><span class="pre">50</span> <span class="pre">000</span> <span class="pre">000</span></code> for the full moment tensor inversion.
<code class="docutils literal notranslate"><span class="pre">100</span> <span class="pre">000</span></code> samples in the double-couple space corresponds to approximately <code class="docutils literal notranslate"><span class="pre">50</span></code> samples in each parameter (strike, dip cosine, and rake).
While this more dense samplings are possible, this produces a good sampling of the posterior PDF quickly, especially when run in parallel.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If running this in parallel on a server, be aware that because the number of workers option <code class="docutils literal notranslate"><span class="pre">number_workers</span></code> is not set, as many processes as processors will be spawned, slowing down the machine for any other users.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">50</span> <span class="pre">000</span> <span class="pre">000</span></code> samples are used instead of the <code class="docutils literal notranslate"><span class="pre">10</span> <span class="pre">000</span> <span class="pre">000</span></code> samples in the <a class="reference internal" href="#synthetic-p-polarity"><span class="std std-ref">Synthetic P Polarity Inversion</span></a> example because amplitude ratios provide a much stronger constraint on the source type, so more samples are required for an effective sampling of the source PDF.</p>
<p>This script is equivalent to pickling the data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">example_data</span> <span class="k">import</span> <span class="n">synthetic_event</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">=</span><span class="n">synthetic_event</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cPickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;synthetic_event_data.inv&#39;</span><span class="p">,</span><span class="s1">&#39;wb&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>And then calling from the command line (Assuming parallel running: <code class="docutils literal notranslate"><span class="pre">-l</span></code> flag to run on a single processor):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ MTfit --algorithm=iterate --pmem=1 --double-couple --max-samples=100000 \
    --inversion-options=PPolarity,P/SHRMSAmplitudeRatio,P/SVRMSAmplitudeRatio \
    --convert synthetic_event_data.inv
$ MTfit --algorithm=iterate --pmem=1 --max-samples=10000000  \
    --inversion-options=PPolarity,P/SHRMSAmplitudeRatio,P/SVRMSAmplitudeRatio \
    --convert synthetic_event_data.inv
</pre></div>
</div>
<p>These inversions should not take long to run (running on a single core of an i5 processor, the two inversions take 20 and 436 seconds respectively), although the conversions using <code class="xref py py-mod docutils literal notranslate"><span class="pre">MTfit.MTconvert</span></code> can add to this time, but will reduce the time when plotting the results. These run times are longer than for only polarity data, both because of the additional data, and the increased complexity of the <span class="xref std std-ref">ratio-pdf-label</span>. The solutions are outputted as a MATLAB file for the DC and MT solutions respectively, with name <code class="docutils literal notranslate"><span class="pre">synthetic_example_event_arDC.mat</span></code> and <code class="docutils literal notranslate"><span class="pre">synthetic_example_event_arMT.mat</span></code> respectively.</p>
<div class="figure align-center" id="id9" style="width: 70%">
<span id="synthetic-event-ar-fig"></span><a class="reference internal image-reference" href="_images/synthetic_event_ar.png"><img alt="Beachball plot showing the fault plane orientations for the double-couple constrained inversion and the marginalised source-type PDF for the full moment tensor inversion of the synthetic data." src="_images/synthetic_event_ar.png" style="width: 90%;" /></a>
<p class="caption"><span class="caption-text"><em>Beachball plot showing the fault plane orientations for the double-couple constrained inversion and the marginalised source-type PDF for the full moment tensor inversion of the synthetic data using polarities and amplitude ratios (Plotted using MTplot MATLAB code).</em></span></p>
</div>
</div>
</div>
<div class="section" id="krafla-event">
<h2>5.2. Krafla Event<a class="headerlink" href="#krafla-event" title="Permalink to this headline">¶</a></h2>
<div class="figure align-right" id="id10" style="width: 30%">
<a class="reference internal image-reference" href="_images/krafla_event_location_uncertainty.png"><img alt="Beachball plot of the krafla location uncertainty" src="_images/krafla_event_location_uncertainty.png" style="width: 90%;" /></a>
<p class="caption"><span class="caption-text"><em>Beachball plot of the effect of the location uncertainty on the receivers (dots, darker are higher probability locations) (Plotted using MTplot MATLAB code)</em></span></p>
</div>
<p>A strongly non-double-couple event, with manually picked P and S arrival times and P polarities, and then located using <a class="reference external" href="http://alomax.free.fr/nlloc">NonLinLoc</a> is used as an example for inversions with real data. In this case the S arrivals were hard to measure an amplitude for, so amplitude ratios are ignored. Instead, polarities and polarity probabilities (calculated using the approach described in <a class="reference internal" href="references.html#pugh-2016a"><span class="std std-ref">Pugh et al. 2016a</span></a> and implemented in :ref:rom <code class="xref py py-mod docutils literal notranslate"><span class="pre">autopol</span></code>) are used separately to invert for the source, along with including the location data. This event is shown in <a class="reference internal" href="references.html#pugh-2016a"><span class="std std-ref">Pugh et al. 2016a</span></a> and investigated in more detail in <a class="reference internal" href="references.html#watson-2015"><span class="std std-ref">Watson et al. 2015</span></a>.</p>
<div class="section" id="krafla-p-polarity-inversion">
<span id="real-p-polarity"></span><h3>5.2.1. Krafla P Polarity Inversion<a class="headerlink" href="#krafla-p-polarity-inversion" title="Permalink to this headline">¶</a></h3>
<p>There are 21 P-polarity arrivals for the synthetic event, and the locations of these receivers are shown in the figure on the right. There is quite a large depth uncertainty, leading to a large variation in take-off angles (also shown in the figure on the right)</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">example_data</span> <span class="kn">import</span> <span class="n">krafla_event</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">=</span><span class="n">krafla_event</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;PPolarity&#39;</span><span class="p">]</span>
<span class="go">{&#39;Error&#39;: matrix([[0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01],</span>
<span class="go">        [0.01]]), &#39;Measured&#39;: matrix([[-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1],</span>
<span class="go">        [-1]]), &#39;Stations&#39;: {&#39;Azimuth&#39;: matrix([[254.9],</span>
<span class="go">        [102.5],</span>
<span class="go">        [347.4],</span>
<span class="go">        [178.3],</span>
<span class="go">        [215. ],</span>
<span class="go">        [234. ],</span>
<span class="go">        [120.3],</span>
<span class="go">        [350.4],</span>
<span class="go">        [298.6],</span>
<span class="go">        [141.8],</span>
<span class="go">        [288.4],</span>
<span class="go">        [186.2],</span>
<span class="go">        [131.4],</span>
<span class="go">        [ 48.4],</span>
<span class="go">        [239.6],</span>
<span class="go">        [151. ],</span>
<span class="go">        [284. ],</span>
<span class="go">        [ 19.6],</span>
<span class="go">        [100.9],</span>
<span class="go">        [319.8],</span>
<span class="go">        [219.4]]), &#39;Name&#39;: [&#39;KVO0&#39;, &#39;K080&#39;, &#39;K040&#39;, &#39;K200&#39;, &#39;REN0&#39;, </span>
<span class="go">&#39;K120&#39;, &#39;K100&#39;, &#39;K008&#39;, &#39;K020&#39;, &#39;K140&#39;, &#39;K060&#39;, &#39;K250&#39;, &#39;K170&#39;, </span>
<span class="go">&#39;K050&#39;, &#39;K090&#39;, &#39;K210&#39;, &#39;K010&#39;, &#39;GHA0&#39;, &#39;K110&#39;, &#39;K070&#39;, &#39;K220&#39;], </span>
<span class="go">&#39;TakeOffAngle&#39;: matrix([[ 77. </span>
<span class="go">],</span>
<span class="go">        [108.8],</span>
<span class="go">        [104.3],</span>
<span class="go">        [ 87.4],</span>
<span class="go">        [ 69.7],</span>
<span class="go">        [ 86.2],</span>
<span class="go">        [ 90.4],</span>
<span class="go">        [ 72.1],</span>
<span class="go">        [ 78.8],</span>
<span class="go">        [ 90. ],</span>
<span class="go">        [103.2],</span>
<span class="go">        [ 73.2],</span>
<span class="go">        [ 74.7],</span>
<span class="go">        [101.1],</span>
<span class="go">        [103.6],</span>
<span class="go">        [ 76.3],</span>
<span class="go">        [ 71.5],</span>
<span class="go">        [ 68.1],</span>
<span class="go">        [ 86.3],</span>
<span class="go">        [137.5],</span>
<span class="go">        [ 72.6]])}}</span>
</pre></div>
</div>
</div></blockquote>
<p><a class="reference download internal" href="_downloads/krafla_event.py" download=""><code class="xref download docutils literal notranslate"><span class="pre">examples/krafla_event.py</span></code></a> contains a script for the double-couple and full moment tensor inversion of the source. It can be run as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ python krafla_event.py case=ppolarity
</pre></div>
</div>
<p>Adding a <code class="docutils literal notranslate"><span class="pre">-l</span></code> flag will run the inversion in a single thread.</p>
<p>The important part of the script is:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># print output data</span>
<span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;PPolarity&#39;</span><span class="p">])</span>
<span class="n">data</span><span class="p">[</span><span class="s1">&#39;UID&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;_ppolarity&#39;</span>
<span class="c1"># Set inversion parameters</span>
<span class="c1"># Use an iteration random sampling algorithm</span>
<span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;iterate&#39;</span>
<span class="c1"># Run in parallel if set on command line</span>
<span class="n">parallel</span> <span class="o">=</span> <span class="n">parallel</span>
<span class="c1"># uses a soft memory limit of 1Gb of RAM for estimating the sample sizes</span>
<span class="c1"># (This is only a soft limit, so no errors are thrown if the memory usage</span>
<span class="c1">#         increases above this)</span>
<span class="n">phy_mem</span> <span class="o">=</span> <span class="mi">1</span>
<span class="c1"># Run in double-couple space only</span>
<span class="n">dc</span> <span class="o">=</span> <span class="bp">True</span>
<span class="c1"># Run for one hundred thousand samples</span>
<span class="n">max_samples</span> <span class="o">=</span> <span class="mi">100000</span>
<span class="c1"># Set to only use P Polarity data</span>
<span class="n">inversion_options</span> <span class="o">=</span> <span class="s1">&#39;PPolarity&#39;</span>
<span class="c1"># Set the convert flag to convert the output to other source parameterisations</span>
<span class="n">convert</span> <span class="o">=</span> <span class="bp">True</span>
<span class="c1"># Set location uncertainty file path</span>
<span class="n">location_pdf_file_path</span> <span class="o">=</span> <span class="s1">&#39;krafla_event.scatangle&#39;</span>
<span class="c1"># Handle location uncertainty</span>
<span class="c1"># Set number of location samples to use (randomly sampled from PDF) as this</span>
<span class="c1">#    reduces calculation time</span>
<span class="c1"># (each location sample is equivalent to running an additional event)</span>
<span class="n">number_location_samples</span> <span class="o">=</span> <span class="mi">5000</span>
<span class="c1"># Bin Scatangle File</span>
<span class="n">bin_scatangle</span> <span class="o">=</span> <span class="bp">True</span>
<span class="c1"># Use MTfit.__core__.MTfit function</span>
<span class="n">MTfit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">location_pdf_file_path</span><span class="o">=</span><span class="n">location_pdf_file_path</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="n">algorithm</span><span class="p">,</span>
      <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span> <span class="n">inversion_options</span><span class="o">=</span><span class="n">inversion_options</span><span class="p">,</span> <span class="n">phy_mem</span><span class="o">=</span><span class="n">phy_mem</span><span class="p">,</span> <span class="n">dc</span><span class="o">=</span><span class="n">dc</span><span class="p">,</span>
      <span class="n">max_samples</span><span class="o">=</span><span class="n">max_samples</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="n">convert</span><span class="p">,</span> <span class="n">bin_scatangle</span><span class="o">=</span><span class="n">bin_scatangle</span><span class="p">,</span>
      <span class="n">number_location_samples</span><span class="o">=</span><span class="n">number_location_samples</span><span class="p">)</span>
<span class="c1"># Change max_samples for MT inversion</span>
<span class="n">max_samples</span> <span class="o">=</span> <span class="mi">1000000</span>
<span class="c1"># Create the inversion object with the set parameters.</span>
<span class="n">MTfit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">location_pdf_file_path</span><span class="o">=</span><span class="n">location_pdf_file_path</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="n">algorithm</span><span class="p">,</span>
      <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span> <span class="n">inversion_options</span><span class="o">=</span><span class="n">inversion_options</span><span class="p">,</span> <span class="n">phy_mem</span><span class="o">=</span><span class="n">phy_mem</span><span class="p">,</span>
      <span class="n">dc</span><span class="o">=</span><span class="ow">not</span> <span class="n">dc</span><span class="p">,</span> <span class="n">max_samples</span><span class="o">=</span><span class="n">max_samples</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="n">convert</span><span class="p">,</span>
      <span class="n">bin_scatangle</span><span class="o">=</span><span class="n">bin_scatangle</span><span class="p">,</span> <span class="n">number_location_samples</span><span class="o">=</span><span class="n">number_location_samples</span><span class="p">)</span>
<span class="c1"># Equivalent to pickling the data and outputting the location uncertainty:</span>
<span class="c1">#  &gt;&gt;&gt; from example_data import krafla_event,krafla_location</span>
<span class="c1">#  &gt;&gt;&gt; data=krafla_event()</span>
<span class="c1">#  &gt;&gt;&gt; open(&#39;krafla_event.scatangle&#39;,&#39;w&#39;).write(krafla_location())</span>
<span class="c1">#  &gt;&gt;&gt; import cPickle</span>
<span class="c1">#  &gt;&gt;&gt; cPickle.dump(data,open(&#39;krafla_event.inv&#39;,&#39;wb&#39;))</span>
<span class="c1"># And then calling from the command line</span>
<span class="c1">#  MTfit --location_pdf_file_path=krafla_event.scatangle --algorithm=iterate \</span>
<span class="c1">#    --pmem=1 --double-couple --max-samples=100000 \</span>
<span class="c1">#    --inversion-options=PPolarity --convert --bin-scatangle krafla_event.inv</span>
<span class="c1">#  MTfit --location_pdf_file_path=krafla_event.scatangle --algorithm=iterate \</span>
<span class="c1">#    --pmem=1 --max-samples=10000000  --inversion-options=PPolarity --convert \</span>
<span class="c1">#    --bin-scatangle krafla_event.inv</span>
</pre></div>
</div>
</div></blockquote>
<p>In this example the <code class="xref py py-func docutils literal notranslate"><span class="pre">MTfit.__core__.MTfit()</span></code>  function is used instead of creating the inversion object directly. Again, the chosen algorithm is the <code class="docutils literal notranslate"><span class="pre">iterate</span></code> algorithm (see <a class="reference internal" href="algorithms.html#mcsampling"><span class="std std-ref">Random Monte Carlo sampling</span></a>) for <code class="docutils literal notranslate"><span class="pre">100</span> <span class="pre">000</span></code> samples for the double-couple case and <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">000</span> <span class="pre">000</span></code> for the full moment tensor inversion. The location uncertainty distribution is binned (<code class="docutils literal notranslate"><span class="pre">--bin_scatangle</span></code>), which runs before the main inversion is carried out. This uses the <a class="reference internal" href="source-scatangle.html"><span class="doc">MTfit.extensions.scatangle</span></a> extension to both parse and bin the location PDF distribution.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If running this in parallel on a server, be aware that because the number of workers option <code class="docutils literal notranslate"><span class="pre">number_workers</span></code> is not set, as many processes as processors will be spawned, slowing down the machine for any other users.</p>
</div>
<p>This script is equivalent to pickling the data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">example_data</span> <span class="k">import</span> <span class="n">krafla_event</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">=</span><span class="n">krafla_event</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cPickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;krafla_event_data.inv&#39;</span><span class="p">,</span><span class="s1">&#39;wb&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>And then calling from the command line (Assuming parallel running: <code class="docutils literal notranslate"><span class="pre">-l</span></code> flag to run on a single processor):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ MTfit --location_pdf_file_path=krafla_event.scatangle --algorithm=iterate \
    --pmem=1 --double-couple --max-samples=100000 --inversion-options=PPolarity \
    --convert --bin-scatangle krafla_event_data.inv
$ MTfit --location_pdf_file_path=krafla_event.scatangle --algorithm=iterate \
    --pmem=1 --max-samples=10000000  --inversion-options=PPolarity --convert \
    --bin-scatangle krafla_event_data.inv
</pre></div>
</div>
<p>These inversions will take longer to run than the previous examples, due to the location uncertainty (running using 8 cores, the two inversions take 4 and 11 minutes respectively), although the conversions using <code class="xref py py-mod docutils literal notranslate"><span class="pre">MTfit.MTconvert</span></code> can add to this time, but will reduce the time when plotting the results. The solutions are outputted as a MATLAB file for the DC and MT solutions respectively, with name <code class="docutils literal notranslate"><span class="pre">krafla_event_ppolarityDC.mat</span></code> and <code class="docutils literal notranslate"><span class="pre">krafla_event_ppolarityMT.mat</span></code> respectively.</p>
<div class="figure align-center" id="id12" style="width: 70%">
<span id="krafla-event-p-polarity"></span><a class="reference internal image-reference" href="_images/krafla_event_p_polarity.png"><img alt="Beachball plot showing the fault plane orientations for the double-couple constrained inversion and the marginalised source-type PDF for the full moment tensor inversion of the krafla data." src="_images/krafla_event_p_polarity.png" style="width: 90%;" /></a>
<p class="caption"><span class="caption-text"><em>Beachball plot showing the fault plane orientations for the double-couple constrained inversion and the marginalised source-type PDF for the full moment tensor inversion of the krafla data using polarities(Plotted using MTplot MATLAB code).</em></span></p>
</div>
</div>
<div class="section" id="krafla-p-polarity-probability-inversion">
<span id="real-p-polarity-probability"></span><h3>5.2.2. Krafla P Polarity Probability Inversion<a class="headerlink" href="#krafla-p-polarity-probability-inversion" title="Permalink to this headline">¶</a></h3>
<p>There are 21 P-polarity arrivals for the synthetic event, but more observations, and a better understanding of the uncertainties on the polarities can be obtained using the automated Bayesian polarity probabilities generated using the approach described in <a class="reference internal" href="references.html#pugh-2016b"><span class="std std-ref">Pugh et al., 2016b</span></a>, <span class="xref std std-ref">Pugh, 2016a</span>. Nevertheless, much of this example is the same as the <a class="reference internal" href="#real-p-polarity"><span class="std std-ref">Krafla P Polarity Inversion</span></a> example.</p>
<p><a class="reference download internal" href="_downloads/krafla_event.py" download=""><code class="xref download docutils literal notranslate"><span class="pre">examples/krafla_event.py</span></code></a> contains a script for the double-couple and full moment tensor inversion of the source. It can be run as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ python krafla_event.py case=ppolarityprob
</pre></div>
</div>
<p>Adding a <code class="docutils literal notranslate"><span class="pre">-l</span></code> flag will run the inversion in a single thread.</p>
<p>The important part of the script is:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># print output data</span>
<span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;PPolarityProb&#39;</span><span class="p">])</span>
<span class="n">data</span><span class="p">[</span><span class="s1">&#39;UID&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;_ppolarityprob&#39;</span>
<span class="c1"># Set inversion parameters</span>
<span class="c1"># Use an mcmc sampling algorithm</span>
<span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;mcmc&#39;</span>
<span class="c1"># Set parallel to false as running McMC</span>
<span class="n">parallel</span> <span class="o">=</span> <span class="bp">False</span>
<span class="c1"># uses a soft memory limit of 0.5Gb of RAM for estimating the sample sizes</span>
<span class="c1"># (This is only a soft limit, so no errors are thrown if the memory usage</span>
<span class="c1">#     increases above this)</span>
<span class="n">phy_mem</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="c1"># Run both inversions</span>
<span class="n">dc_mt</span> <span class="o">=</span> <span class="bp">True</span>
<span class="c1"># Run for one hundred thousand samples</span>
<span class="n">chain_length</span> <span class="o">=</span> <span class="mi">100000</span>
<span class="c1"># Set to only use P Polarity data</span>
<span class="n">inversion_options</span> <span class="o">=</span> <span class="s1">&#39;PPolarityProb&#39;</span>
<span class="c1"># Set the convert flag to convert the output to other source parameterisations</span>
<span class="n">convert</span> <span class="o">=</span> <span class="bp">True</span>
<span class="c1"># Set location uncertainty file path</span>
<span class="n">location_pdf_file_path</span> <span class="o">=</span> <span class="s1">&#39;krafla_event.scatangle&#39;</span>
<span class="c1"># Handle location uncertainty</span>
<span class="c1"># Set number of location samples to use (randomly sampled from PDF) as this</span>
<span class="c1">#    reduces calculation time</span>
<span class="c1"># (each location sample is equivalent to running an additional event)</span>
<span class="n">number_location_samples</span> <span class="o">=</span> <span class="mi">5000</span>
<span class="c1"># Bin Scatangle File</span>
<span class="n">bin_scatangle</span> <span class="o">=</span> <span class="bp">True</span>
<span class="c1"># Use MTfit.__core__.MTfit function</span>
<span class="n">MTfit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">location_pdf_file_path</span><span class="o">=</span><span class="n">location_pdf_file_path</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="n">algorithm</span><span class="p">,</span>
      <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span> <span class="n">inversion_options</span><span class="o">=</span><span class="n">inversion_options</span><span class="p">,</span> <span class="n">phy_mem</span><span class="o">=</span><span class="n">phy_mem</span><span class="p">,</span>
      <span class="n">chain_length</span><span class="o">=</span><span class="n">chain_length</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="n">convert</span><span class="p">,</span> <span class="n">bin_scatangle</span><span class="o">=</span><span class="n">bin_scatangle</span><span class="p">,</span>
      <span class="n">dc_mt</span><span class="o">=</span><span class="n">dc_mt</span><span class="p">,</span> <span class="n">number_location_samples</span><span class="o">=</span><span class="n">number_location_samples</span><span class="p">)</span>
<span class="c1"># Trans-Dimensional inversion</span>
<span class="n">data</span><span class="p">[</span><span class="s1">&#39;UID&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;_transd&#39;</span>
<span class="c1"># Use a transdmcmc sampling algorithm</span>
<span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;transdmcmc&#39;</span>
<span class="c1"># Use MTfit.__core__.MTfit function</span>
<span class="n">MTfit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">location_pdf_file_path</span><span class="o">=</span><span class="n">location_pdf_file_path</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="n">algorithm</span><span class="p">,</span>
      <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span> <span class="n">inversion_options</span><span class="o">=</span><span class="n">inversion_options</span><span class="p">,</span> <span class="n">phy_mem</span><span class="o">=</span><span class="n">phy_mem</span><span class="p">,</span>
      <span class="n">chain_length</span><span class="o">=</span><span class="n">chain_length</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="n">convert</span><span class="p">,</span> <span class="n">bin_scatangle</span><span class="o">=</span><span class="n">bin_scatangle</span><span class="p">,</span>
      <span class="n">number_location_samples</span><span class="o">=</span><span class="n">number_location_samples</span><span class="p">)</span>
<span class="c1"># Equivalent to pickling the data and outputting the location uncertainty:</span>
<span class="c1">#  &gt;&gt;&gt; from example_data import krafla_event,krafla_location</span>
<span class="c1">#  &gt;&gt;&gt; data=krafla_event()</span>
<span class="c1">#  &gt;&gt;&gt; open(&#39;krafla_event.scatangle&#39;,&#39;w&#39;).write(krafla_location())</span>
<span class="c1">#  &gt;&gt;&gt; import cPickle</span>
<span class="c1">#  &gt;&gt;&gt; cPickle.dump(data,open(&#39;krafla_event_data.inv&#39;,&#39;wb&#39;))</span>
<span class="c1"># And then calling from the command line</span>
<span class="c1"># MTfit --location_pdf_file_path=krafla_event.scatangle --algorithm=mcmc -b \</span>
<span class="c1">#    --pmem=1 --double-couple --max-samples=100000 \</span>
<span class="c1">#    --inversion-options=PPolarityProb --convert --bin-scatangle \</span>
<span class="c1">#    krafla_event.inv</span>
<span class="c1"># MTfit --location_pdf_file_path=krafla_event.scatangle --algorithm=transdmcmc \</span>
<span class="c1">#    --pmem=1 --max-samples=100000  --inversion-options=PPolarityProb \</span>
<span class="c1">#    --convert --bin-scatangle krafla_event.inv</span>
</pre></div>
</div>
</div></blockquote>
<p>In this example the <code class="xref py py-func docutils literal notranslate"><span class="pre">MTfit.__core__.MTfit()</span></code>  function is used instead of creating the inversion object directly. The chosen algorithm is the <code class="docutils literal notranslate"><span class="pre">mcmc</span></code> algorithm (see <a class="reference internal" href="algorithms.html#mcmcsampling"><span class="std std-ref">Markov chain Monte Carlo sampling</span></a>) for a chain length of <code class="docutils literal notranslate"><span class="pre">100</span> <span class="pre">000</span></code> samples for both the double-couple case and the full moment tensor inversion. Additionally a trans-dimensional McMC approach is run, allowing comparison between the two.</p>
<p>The location uncertainty distribution is binned (<code class="docutils literal notranslate"><span class="pre">--bin_scatangle</span></code>), which runs before the main inversion is carried out. This uses the <a class="reference internal" href="source-scatangle.html"><span class="doc">MTfit.extensions.scatangle</span></a> extension to both parse and bin the location PDF distribution.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If running this in parallel on a server, be aware that because the number of workers option <code class="docutils literal notranslate"><span class="pre">number_workers</span></code> is not set, as many processes as processors will be spawned, slowing down the machine for any other users.</p>
</div>
<p>This script is equivalent to pickling the data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">example_data</span> <span class="k">import</span> <span class="n">krafla_event</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">=</span><span class="n">krafla_event</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cPickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;krafla_event_data.inv&#39;</span><span class="p">,</span><span class="s1">&#39;wb&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>And then calling from the command line:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ MTfit --location_pdf_file_path=krafla_event.scatangle -l --algorithm=mcmc -b \
    --pmem=1 --double-couple --max-samples=100000 --inversion-options=PPolarityProb \
    --convert --bin-scatangle krafla_event_data.inv
$ MTfit --location_pdf_file_path=krafla_event.scatangle -l --algorithm=transdmcmc \
    --pmem=1 --max-samples=100000  --inversion-options=PPolarityProb --convert \
    --bin-scatangle krafla_event_data.inv
</pre></div>
</div>
<p>These inversions will take longer to run than the previous examples, both due to the location uncertainty, the McMC algorithms, and the non-parallel running (running on a single process on an i5 processor, the  inversions take 7 hours), although the conversions using <code class="xref py py-mod docutils literal notranslate"><span class="pre">MTfit.MTconvert</span></code> can add to this time, but will reduce the time when plotting the results. The solutions are outputted as a MATLAB file for the DC and MT solutions respectively, with name <code class="docutils literal notranslate"><span class="pre">krafla_event_ppolarityDC.mat</span></code> and <code class="docutils literal notranslate"><span class="pre">krafla_event_ppolarityMT.mat</span></code> respectively.</p>
<div class="figure align-center" id="id13" style="width: 70%">
<span id="krafla-event-p-polarity-prob"></span><a class="reference internal image-reference" href="_images/krafla_event_p_polarity_probability.png"><img alt="Beachball plot showing the fault plane orientations for the double-couple constrained inversion and the marginalised source-type PDF for the full moment tensor inversion of the krafla data." src="_images/krafla_event_p_polarity_probability.png" style="width: 90%;" /></a>
<p class="caption"><span class="caption-text"><em>Beachball plot showing the fault plane orientations for the double-couple constrained inversion and the marginalised source-type PDF for the full moment tensor inversion of the krafla data using polarity probabilities (Plotted using MTplot MATLAB code).</em></span></p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">transdmcmc</span></code> algorithm option produces similar results to the normal McMC example, and both results are consistent with the random sampling approach for polarity data (<a class="reference internal" href="#real-p-polarity"><span class="std std-ref">Krafla P Polarity</span></a>). The chain-lengths may be on the long side, and it is possible that shorter chains would produce satisfactory sampling of the solution PDF.</p>
<div class="figure align-right" id="id15" style="width: 40%">
<a class="reference internal image-reference" href="_images/krafla_event_p_polarity_probability_transd.png"><img alt="The marginalised source-type PDF for the full moment tensor inversion of the krafla data." src="_images/krafla_event_p_polarity_probability_transd.png" style="width: 90%;" /></a>
<p class="caption"><span class="caption-text"><em>The marginalised source-type PDF for the full moment tensor inversion of the krafla data using polarity probabilities and the reversible jump (trans-dimensional) McMC approach (Plotted using MTplot MATLAB code).</em></span></p>
</div>
</div>
</div>
<div class="section" id="bayesian-evidence">
<span id="id5"></span><h2>5.3. Bayesian Evidence<a class="headerlink" href="#bayesian-evidence" title="Permalink to this headline">¶</a></h2>
<p>The Bayesian evidence estimates the evidence for the model given the posterior PDF and the parameter priors. It accounts for the model dimensions, and can penalise the higher dimensional model by the parameter priors. The Bayesian evidence is:</p>
<div class="math notranslate nohighlight">
\[\mathrm{p}\left(data|model\right)=\int_\mathrm{x}\mathrm{p}\left(data|x\right)\mathrm{p}\left(x|model\right)\mathrm{d}x.\]</div>
<p>Since <code class="xref py py-mod docutils literal notranslate"><span class="pre">MTfit</span></code> produces random samples of the source PDF, so the Bayesian evidence is calculated as a sum over the samples:</p>
<div class="math notranslate nohighlight">
\[\mathrm{p}\left(data|model\right)=\sum_{x}\mathrm{p}\left(data|x\right)\mathrm{p}\left(x|model\right)\delta x,\]</div>
<p>but care must be taken with the choice of the prior parameterisation. This must correspond to the same parameterisation in which the Monte Carlo samples were drawn, either directly or by correcting both the prior distribution and the <span class="math notranslate nohighlight">\(\delta x\)</span> values. A Monte Carlo approach can be affected by small sample sizes in the integration, which is sometimes the case when the source PDF is dominated by a few very large probability samples.</p>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">MTfit</span></code> produces a Bayesian evidence estimate for a constrained inversion. These can be combined for the DC and MT models, with <span class="math notranslate nohighlight">\(\mathcal{B}\)</span> corresponding to a Bayesian evidence estimate:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{ln}\left(\mathcal{B}_\mathrm{max}\right)=\mathrm{max}\left(\mathrm{ln}\left(\mathcal{B}_\mathrm{DC}\right),\mathrm{ln}\left(\mathcal{B}_\mathrm{MT}\right)\right),\\
p_\mathrm{DC}=\frac{\mathrm{e}^{\mathrm{ln}\left(\mathcal{B}_\mathrm{DC}\right)-\mathrm{ln}\left(\mathcal{B}_\mathrm{max}\right)}}{\mathrm{e}^{\mathrm{ln}\left(\mathcal{B}_\mathrm{DC}\right)-\mathrm{ln}\left(\mathcal{B}_\mathrm{max}\right)}+\mathrm{e}^{\mathrm{ln}\left(\mathcal{B}_\mathrm{MT}\right)-\mathrm{ln}\left(\mathcal{B}_\mathrm{max}\right)}},\\
p_\mathrm{MT}=\frac{\mathrm{e}^{\mathrm{ln}\left(\mathcal{B}_\mathrm{MT}\right)-\mathrm{ln}\left(\mathcal{B}_\mathrm{max}\right)}}{\mathrm{e}^{\mathrm{ln}\left(\mathcal{B}_\mathrm{DC}\right)-\mathrm{ln}\left(\mathcal{B}_\mathrm{max}\right)}+\mathrm{e}^{\mathrm{ln}\left(\mathcal{B}_\mathrm{MT}\right)-\mathrm{ln}\left(\mathcal{B}_\mathrm{max}\right)}}.\end{split}\]</div>
<p>For the examples shown above, the model probability estimates from the Bayesian evidence are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="21%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Example</th>
<th class="head"><span class="math notranslate nohighlight">\(p_\mathrm{DC}\)</span></th>
<th class="head"><span class="math notranslate nohighlight">\(p_\mathrm{MT}\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#synthetic-p-polarity"><span class="std std-ref">Synthetic Polarities</span></a></td>
<td><span class="math notranslate nohighlight">\(0.64\)</span></td>
<td><span class="math notranslate nohighlight">\(0.36\)</span></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#synthetic-ar"><span class="std std-ref">Synthetic Polarity and Amplitude Ratios</span></a></td>
<td><span class="math notranslate nohighlight">\(0.82\)</span></td>
<td><span class="math notranslate nohighlight">\(0.18\)</span></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#real-p-polarity"><span class="std std-ref">Krafla P Polarity</span></a></td>
<td><span class="math notranslate nohighlight">\(0.0008\)</span></td>
<td><span class="math notranslate nohighlight">\(0.9992\)</span></td>
</tr>
</tbody>
</table>
<p>These can be calculated using the <a class="reference internal" href="#MTfit.probability.model_probabilities" title="MTfit.probability.model_probabilities"><code class="xref py py-func docutils literal notranslate"><span class="pre">MTfit.probability.model_probabilities()</span></code></a> function, which takes the logarithm of the Bayesian evidence for each model type as an argument:</p>
<dl class="function">
<dt id="MTfit.probability.model_probabilities">
<code class="descclassname">MTfit.probability.</code><code class="descname">model_probabilities</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/MTfit/probability/probability.html#model_probabilities"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MTfit.probability.model_probabilities" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the model probabilities for a discrete set of models using the
ln_bayesian_evidences, provided as args.</p>
<p>e.g. to compare between DC and MT:</p>
<blockquote>
<div>pDC,pMT=model_probabilities(dc_ln_bayesian_evidence,mt_ln_bayesian_evidence)</div></blockquote>
<dl class="docutils">
<dt>Args</dt>
<dd>floats - ln_bayesian_evidence for each model type</dd>
<dt>Returns</dt>
<dd><dl class="first last docutils">
<dt>tuple: Tuple of the normalised model probabilities for the corresponding</dt>
<dd>ln_bayesian_evidence inputs</dd>
</dl>
</dd>
</dl>
</dd></dl>

<p>The normal McMC approach cannot be used to estimate the model probabilities, however the trans-dimensional example is consistent with the <a class="reference internal" href="#real-p-polarity"><span class="std std-ref">Krafla P Polarity</span></a> model probabilities as that produces an estimate <span class="math notranslate nohighlight">\(p_\mathrm{DC}=0\)</span>.</p>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">MTfit</span></code> also calculates the Kullback-Liebler divergence of the resultant PDF from the sampling prior, which is a measure of how much difference there is between the resultant PDF and the prior information. This is outputted during the inversion approach (when using Monte Carlo random sampling), and saved to the output file.</p>
</div>
<div class="section" id="joint-inversion">
<span id="relative-inversion"></span><h2>5.4. Joint Inversion<a class="headerlink" href="#joint-inversion" title="Permalink to this headline">¶</a></h2>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">MTfit</span></code> can also carry out joint invesions and include relative amplitude data (<a class="reference internal" href="references.html#pugh-2015t"><span class="std std-ref">Pugh et al., 2015t</span></a>). This examples uses data from two co-located synthetic events with overlapping receivers.
<a class="reference download internal" href="_downloads/relative_event.py" download=""><code class="xref download docutils literal notranslate"><span class="pre">examples/relative_event.py</span></code></a> contains a script for the double-couple and full moment tensor inversion of the source. It can be run as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ python relative_event.py
</pre></div>
</div>
<p>Adding a <code class="docutils literal notranslate"><span class="pre">-l</span></code> flag will run the inversion in a single thread.</p>
<p>The important part of the script is:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set inversion parameters</span>
<span class="c1"># Use an iteration random sampling algorithm</span>
<span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;iterate&#39;</span>
<span class="c1"># Run in parallel if set on command line</span>
<span class="n">parallel</span> <span class="o">=</span> <span class="n">parallel</span>
<span class="c1"># uses a soft memory limit of 1Gb of RAM for estimating the sample sizes</span>
<span class="c1"># (This is only a soft limit, so no errors are thrown if the memory usage</span>
<span class="c1">#       increases above this)</span>
<span class="n">phy_mem</span> <span class="o">=</span> <span class="mi">1</span>
<span class="c1"># Run in double-couple space only</span>
<span class="n">dc</span> <span class="o">=</span> <span class="bp">True</span>
<span class="c1"># Run for 10 million samples - quite coarse for relative inversion of two events</span>
<span class="n">max_samples</span> <span class="o">=</span> <span class="mi">10000000</span>
<span class="c1"># Set to only use P Polarity data</span>
<span class="n">inversion_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;PPolarity&#39;</span><span class="p">,</span> <span class="s1">&#39;PAmplitude&#39;</span><span class="p">]</span>
<span class="c1"># Set the convert flag to convert the output to other source parameterisations</span>
<span class="n">convert</span> <span class="o">=</span> <span class="bp">True</span>
<span class="c1"># Create the inversion object with the set parameters.</span>
<span class="n">inversion_object</span> <span class="o">=</span> <span class="n">Inversion</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span>
                             <span class="n">inversion_options</span><span class="o">=</span><span class="n">inversion_options</span><span class="p">,</span> <span class="n">phy_mem</span><span class="o">=</span><span class="n">phy_mem</span><span class="p">,</span> <span class="n">dc</span><span class="o">=</span><span class="n">dc</span><span class="p">,</span>
                             <span class="n">max_samples</span><span class="o">=</span><span class="n">max_samples</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="n">convert</span><span class="p">,</span> <span class="n">multiple_events</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                             <span class="n">relative_amplitude</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c1"># Run the forward model</span>
<span class="n">inversion_object</span><span class="o">.</span><span class="n">forward</span><span class="p">()</span>
<span class="c1"># Run the full moment tensor inversion</span>
<span class="c1"># Use mcmc algorithm for full mt space as random sampling can require a</span>
<span class="c1"># prohibitive number of samples</span>
<span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;mcmc&#39;</span>
<span class="c1"># Set McMC parameters</span>
<span class="n">burn_length</span> <span class="o">=</span> <span class="mi">30000</span>
<span class="n">chain_length</span> <span class="o">=</span> <span class="mi">100000</span>
<span class="n">min_acceptance_rate</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">max_acceptance_rate</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="c1"># Create the inversion object with the set parameters.</span>
<span class="n">inversion_object</span> <span class="o">=</span> <span class="n">Inversion</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                             <span class="n">inversion_options</span><span class="o">=</span><span class="n">inversion_options</span><span class="p">,</span> <span class="n">phy_mem</span><span class="o">=</span><span class="n">phy_mem</span><span class="p">,</span> <span class="n">dc</span><span class="o">=</span><span class="ow">not</span> <span class="n">dc</span><span class="p">,</span>
                             <span class="n">chain_length</span><span class="o">=</span><span class="n">chain_length</span><span class="p">,</span> <span class="n">max_acceptance_rate</span><span class="o">=</span><span class="n">max_acceptance_rate</span><span class="p">,</span>
                             <span class="n">min_acceptance_rate</span><span class="o">=</span><span class="n">min_acceptance_rate</span><span class="p">,</span> <span class="n">burn_length</span><span class="o">=</span><span class="n">burn_length</span><span class="p">,</span>
                             <span class="n">convert</span><span class="o">=</span><span class="n">convert</span><span class="p">,</span> <span class="n">multiple_events</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">relative_amplitude</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c1"># Run the forward model</span>
<span class="n">inversion_object</span><span class="o">.</span><span class="n">forward</span><span class="p">()</span>
<span class="c1"># Equivalent to pickling the data:</span>
<span class="c1">#  &gt;&gt;&gt; from example_data import relative_event</span>
<span class="c1">#  &gt;&gt;&gt; data=relative_event()</span>
<span class="c1">#  &gt;&gt;&gt; import cPickle</span>
<span class="c1">#  &gt;&gt;&gt; cPickle.dump(data,open(&#39;relative_event_data.inv&#39;,&#39;wb&#39;))</span>
<span class="c1"># And then calling from the command line</span>
<span class="c1">#  MTfit --algorithm=iterate --pmem=1 --double-couple --max-samples=10000000 \</span>
<span class="c1">#    --inversion-options=PPolarity,PAmplitude --convert --relative \</span>
<span class="c1">#    --multiple-events relative_event_data.inv</span>
<span class="c1">#  MTfit --algorithm=mcmc --pmem=1 --chain-length=100000  \</span>
<span class="c1">#    --burn_in=30000 --min_acceptance_rate=0.1 \</span>
<span class="c1">#    --max_acceptance_rate=0.3 --inversion-options=PPolarity,PAmplitude \</span>
<span class="c1">#    --convert --relative --multiple-events relative_event_data.inv</span>
</pre></div>
</div>
</div></blockquote>
<p>In this example the <a class="reference internal" href="inversion.html#MTfit.inversion.Inversion" title="MTfit.inversion.Inversion"><code class="xref py py-class docutils literal notranslate"><span class="pre">MTfit.inversion.Inversion</span></code></a>  class is created directly. The chosen algorithm for the double-couple inversion is the <code class="docutils literal notranslate"><span class="pre">iterate</span></code> algorithm (see <a class="reference internal" href="algorithms.html#mcsampling"><span class="std std-ref">Random Monte Carlo sampling</span></a>) for <code class="docutils literal notranslate"><span class="pre">10</span> <span class="pre">000</span> <span class="pre">000</span></code> samples for the double-couple case. A large sample size is required when running the joint inversion because if the probabilities of obtaining a non-zero probability sample for both events is less than or equal to the product of the probabilities of obtaining a non-zero probability sample for the events individually, i.e if the fraction of non-zero probability samples for event 1 is <span class="math notranslate nohighlight">\(f_1\)</span> and the fraction for event 2 is <span class="math notranslate nohighlight">\(f_2\)</span>, then the fraction for the joint samping <span class="math notranslate nohighlight">\(f_j \leq f_1.f_2\)</span>. Consequently it soon becomes infeasible to run the monte-carlo sampling algorithm for the full moment tensor case.</p>
<p>The full moment tensor inversion uses the <code class="docutils literal notranslate"><span class="pre">mcmc</span></code> algorithm to reduce the dependence of the result on the sample size. The burn in length is set to <code class="docutils literal notranslate"><span class="pre">30</span> <span class="pre">000</span></code> and the chain length to <code class="docutils literal notranslate"><span class="pre">100</span> <span class="pre">000</span></code>, while the targeted  acceptance rate window is reduced from the normal McMC selection (0.3 - 0.5), instead targetting between 0.1 and 0.3.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If running this in parallel on a server, be aware that because the number of workers option <code class="docutils literal notranslate"><span class="pre">number_workers</span></code> is not set, as many processes as processors will be spawned, slowing down the machine for any other users.</p>
</div>
<p>This script is equivalent to pickling the data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">example_data</span> <span class="k">import</span> <span class="n">relative_event</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">=</span><span class="n">relative_event</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cPickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;relative_event_data.inv&#39;</span><span class="p">,</span><span class="s1">&#39;wb&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>And then calling from the command line:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ MTfit --algorithm=iterate --pmem=1 --double-couple --max-samples=10000000 \
    --inversion-options=PPolarity,PAmplitude --convert --relative \
    --multiple-events relative_event_data.inv

$ MTfit --algorithm=mcmc --pmem=1 --chain-length=100000  \
    --burn_in=30000 --min_acceptance_rate=0.1 \
    --max_acceptance_rate=0.3 --inversion-options=PPolarity,PAmplitude \
    --convert --relative --multiple-events relative_event_data.inv
</pre></div>
</div>
<p>These inversions will take longer to run than the previous examples, due to the increased sample size required for the joint PDF. The solutions are outputted as a MATLAB file for the DC and MT solutions respectively, with name <code class="docutils literal notranslate"><span class="pre">MTfitOutput_joint_inversionDC.mat</span></code> and <code class="docutils literal notranslate"><span class="pre">MTfitOutput_joint_inversionMT.mat</span></code> respectively.</p>
<div class="figure align-center" id="id16" style="width: 60%">
<a class="reference internal image-reference" href="_images/joint_event.png"><img alt="Beachball plot showing the fault plane orientations for the double-couple constrained inversion and the marginalised source-type PDF for the full moment tensor inversion of the relative data." src="_images/joint_event.png" style="width: 90%;" /></a>
<p class="caption"><span class="caption-text"><em>Beachball plot showing the fault plane orientations for the double-couple constrained inversion and the marginalised source-type PDF for the full moment tensor inversion for two events, inverted  using P polarities and relative P amplitude ratios.</em></span></p>
</div>
<p>These have improved the constraint compared to the joint inversion without relative amplitudes:</p>
<div class="figure align-center" id="id18" style="width: 60%">
<a class="reference internal image-reference" href="_images/joint_event_no_rel.png"><img alt="Beachball plot showing the fault plane orientations for the double-couple constrained inversion and the marginalised source-type PDF for the full moment tensor inversion of the P-polarities." src="_images/joint_event_no_rel.png" style="width: 90%;" /></a>
<p class="caption"><span class="caption-text"><em>Beachball plot showing the fault plane orientations for the double-couple constrained inversion and the marginalised source-type PDF for the full moment tensor inversion for two events, inverted  using P polarities.</em></span></p>
</div>
<p>Althought the constraint has improved, the relative amplitudes have changed the full moment tensor solution for the second event, possibly due to errors in the P-amplitude estimation (<a class="reference internal" href="references.html#pugh-2016a"><span class="std std-ref">Pugh et al., 2016a</span></a>).</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="bayes.html" class="btn btn-neutral float-right" title="6. Bayesian Approach" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="tutorial.html" class="btn btn-neutral" title="4. Tutorial: Using MTfit" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, David Pugh.
      Last updated on Aug 29, 2018 (version 1.0.3a12).

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0.3a12',
            LANGUAGE:'English',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>