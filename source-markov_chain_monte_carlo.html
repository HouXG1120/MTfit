

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>3.1.2.2.3. MTfit.algorithms.markov_chain_monte_carlo &mdash; MTfit documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/style.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="MTfit documentation" href="index.html"/>
        <link rel="up" title="3.1.2. MTfit.algorithms" href="source-algorithms.html"/>
        <link rel="next" title="3.1.3. MTfit.probability" href="source-probability.html"/>
        <link rel="prev" title="3.1.2.2.2. MTfit.algorithms.monte_carlo" href="source-monte_carlo.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> MTfit
          

          
            
            <img src="_static/MTfitsphinx.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                1.0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="setup.html">2. Installing</a></li>
<li class="toctree-l1"><a class="reference internal" href="run.html">3. Running MTfit</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">4. Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="real-tutorial.html">5. Tutorial: Real Data Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="bayes.html">6. Bayesian Approach</a></li>
<li class="toctree-l1"><a class="reference internal" href="probability.html">7. Probability Density Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="algorithms.html">8. Search Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="mtconvert.html">9. Moment Tensor Conversion</a></li>
<li class="toctree-l1"><a class="reference internal" href="cli.html">10. Command Line Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="mtplot.html">11. Plotting</a></li>
<li class="toctree-l1"><a class="reference internal" href="plot_classes.html">1. Plot Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="mtplotcli.html">12. MTplot Command Line Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="inversion.html">13. Inversion Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="extensions.html">14. Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="references.html">15. References</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">2. Glossary</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="source.html">3. Source Code</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="source.html#contents">3.1. Contents:</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="source-inversion.html">3.1.1. MTfit.inversion</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="source-algorithms.html">3.1.2. MTfit.algorithms</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="source-algorithms.html#algorithms">3.1.2.1. Algorithms</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="source-algorithms.html#contents">3.1.2.2. Contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="source-probability.html">3.1.3. MTfit.probability</a></li>
<li class="toctree-l3"><a class="reference internal" href="source-sampling.html">3.1.4. MTfit.sampling</a></li>
<li class="toctree-l3"><a class="reference internal" href="source-run.html">3.1.5. MTfit.run</a></li>
<li class="toctree-l3"><a class="reference internal" href="source-utilities.html">3.1.6. MTfit.utilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="source-extensions.html">3.1.7. MTfit.extensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="source-convert.html">3.1.8. MTfit.convert</a></li>
<li class="toctree-l3"><a class="reference internal" href="source-plot.html">3.1.9. MTfit.plot</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/djpugh/MTfit">GitHub Repository</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MTfit</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="source.html">3. MTfit Source Code</a> &raquo;</li>
        
          <li><a href="source-algorithms.html">3.1.2. MTfit.algorithms</a> &raquo;</li>
        
      <li>3.1.2.2.3. MTfit.algorithms.markov_chain_monte_carlo</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/source-markov_chain_monte_carlo.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="mtfit-algorithms-markov-chain-monte-carlo">
<h1>3.1.2.2.3. MTfit.algorithms.markov_chain_monte_carlo<a class="headerlink" href="#mtfit-algorithms-markov-chain-monte-carlo" title="Permalink to this headline">Â¶</a></h1>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;markov_chain_monte_carlo</span>
<span class="sd">****************************</span>
<span class="sd">Module containing algorithm classes for Markov chain Monte Carlo sampling.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="c1"># **Restricted:  For Non-Commercial Use Only**</span>
<span class="c1"># This code is protected intellectual property and is available solely for teaching</span>
<span class="c1"># and non-commercially funded academic research purposes.</span>
<span class="c1">#</span>
<span class="c1"># Applications for commercial use should be made to Schlumberger or the University of Cambridge.</span>


<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">sys</span>


<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">BaseAlgorithm</span>
<span class="kn">from</span> <span class="nn">.monte_carlo</span> <span class="k">import</span> <span class="n">IterationSample</span>
<span class="kn">from</span> <span class="nn">..probability</span> <span class="k">import</span> <span class="n">gaussian_pdf</span><span class="p">,</span> <span class="n">gaussian_cdf</span><span class="p">,</span> <span class="n">beta_pdf</span><span class="p">,</span> <span class="n">LnPDF</span>
<span class="kn">from</span> <span class="nn">..sampling</span> <span class="k">import</span> <span class="n">Sample</span>
<span class="kn">from</span> <span class="nn">..convert</span> <span class="k">import</span> <span class="n">Tape_MT33</span><span class="p">,</span> <span class="n">basic_cdc_GD</span><span class="p">,</span> <span class="n">MT33_MT6</span><span class="p">,</span> <span class="n">MT6_Tape</span>
<span class="kn">from</span> <span class="nn">..utilities.extensions</span> <span class="k">import</span> <span class="n">get_extensions</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;MTfit.algorithms&#39;</span><span class="p">)</span>

<span class="n">_CYTHON</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">_CYTHON_TESTS</span> <span class="o">=</span> <span class="kc">False</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;McMCAlgorithmCreator&#39;</span><span class="p">,</span>
           <span class="s1">&#39;MarginalisedMarkovChainMonteCarlo&#39;</span><span class="p">,</span>
           <span class="s1">&#39;MarginalisedMetropolisHastings&#39;</span><span class="p">,</span>
           <span class="s1">&#39;MarginalisedMetropolisHastingsGaussianTape&#39;</span><span class="p">,</span>
           <span class="s1">&#39;IterativeMetropolisHastingsGaussianTape&#39;</span><span class="p">,</span>
           <span class="s1">&#39;IterativeTransDMetropolisHastingsGaussianTape&#39;</span><span class="p">,</span>
           <span class="s1">&#39;IterativeMultipleTryMetropolisHastingsGaussianTape&#39;</span><span class="p">,</span>
           <span class="s1">&#39;IterativeMultipleTryTransDMetropolisHastingsGaussianTape&#39;</span><span class="p">]</span>


<span class="c1"># Priors</span>
<span class="k">def</span> <span class="nf">zero_prior</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Evaluates uniform prior probability for x</span>

<span class="sd">    Prior is uniform over surface of 6-sphere rather than the parameterisation. Should not be called</span>

<span class="sd">    Returns</span>
<span class="sd">        float: prior probability</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">uniform_prior</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">dc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basic_cdc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">poisson</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_poisson</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">min_poisson</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Evaluates uniform prior probability for x</span>

<span class="sd">    Prior is uniform over surface of 6-sphere rather than the parameterisation.</span>

<span class="sd">    Returns</span>
<span class="sd">        float: prior probability</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Uniform samples from randomly distributed MT solutions</span>
    <span class="k">if</span> <span class="n">dc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;gamma&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">xi</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">dc</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dc</span> <span class="o">=</span> <span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="n">normalisation_constant</span> <span class="o">=</span> <span class="mf">1.10452194071529090000</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dc</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">basic_cdc</span> <span class="ow">and</span> <span class="s1">&#39;gamma&#39;</span> <span class="ow">in</span> <span class="n">xi</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">p</span> <span class="o">*=</span> <span class="mf">1.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">])</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mf">5.745</span>
        <span class="n">p</span> <span class="o">*=</span> <span class="n">beta_pdf</span><span class="p">((</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">p</span> <span class="o">*=</span> <span class="n">normalisation_constant</span>
    <span class="k">elif</span> <span class="n">basic_cdc</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">poisson</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">probability_poisson</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">max_poisson</span><span class="o">-</span><span class="n">min_poisson</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">probability_poisson</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">*=</span> <span class="mi">1</span><span class="o">/</span><span class="n">probability_poisson</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># handle infinite range for poisson</span>
                <span class="n">p</span> <span class="o">*=</span> <span class="mi">1</span>
        <span class="n">p</span> <span class="o">*=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="c1"># strike dip rake ignored as prior uniform so the ratio in the acceptance</span>
    <span class="c1"># cancels</span>
    <span class="k">return</span> <span class="n">p</span>


<span class="k">def</span> <span class="nf">flat_prior</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">dc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basic_cdc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">poisson</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_poisson</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">min_poisson</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Evaluates flat prior probability for x over parameterisation.</span>

<span class="sd">    Prior is uniform over the parameterisation.</span>

<span class="sd">    Returns</span>
<span class="sd">        float: prior probability</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># uniform flat prior over parameters</span>
    <span class="k">if</span> <span class="n">dc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;gamma&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">xi</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">dc</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dc</span> <span class="o">=</span> <span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dc</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">basic_cdc</span> <span class="ow">and</span> <span class="s1">&#39;gamma&#39;</span> <span class="ow">in</span> <span class="n">xi</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">p</span> <span class="o">*=</span> <span class="mi">3</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">p</span> <span class="o">*=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">elif</span> <span class="n">basic_cdc</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">poisson</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">probability_poisson</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">max_poisson</span><span class="o">-</span><span class="n">min_poisson</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">probability_poisson</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">*=</span> <span class="mi">1</span><span class="o">/</span><span class="n">probability_poisson</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># handle infinite range for poisson</span>
                <span class="n">p</span> <span class="o">*=</span> <span class="mi">1</span>  <span class="c1"># WRONG BUT CAN BE USED (unnormalised but balanced)</span>
        <span class="n">p</span> <span class="o">*=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="c1"># strike dip rake ignored as prior uniform so the ratio in the acceptance</span>
    <span class="c1"># cancels</span>
    <span class="k">return</span> <span class="n">p</span>


<span class="k">class</span> <span class="nc">DataError</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">McMCAlgorithmCreator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates the Markov chain Monte Carlo algorithm from parameters</span>

<span class="sd">    Creates the correct McMC algorithm object depending on the selected mode.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;metropolis_hastings&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">trans_dimensional</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">learning_length</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">parameterisation</span><span class="o">=</span><span class="s1">&#39;tape&#39;</span><span class="p">,</span> <span class="n">transition</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">,</span>
                <span class="n">chain_length</span><span class="o">=</span><span class="mi">1000000</span><span class="p">,</span> <span class="n">min_acceptance_rate</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">max_acceptance_rate</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                <span class="n">acceptance_rate_window</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">initial_sample</span><span class="o">=</span><span class="s1">&#39;grid&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        McMC Creator</span>

<span class="sd">        Returns initialised object of desired type. This is extensible using the</span>
<span class="sd">        MTfit.algorithms.markov_chain_monte_carlo group in pkg_resources (see extensions documentation)</span>
<span class="sd">        to add additional options</span>

<span class="sd">        Args</span>
<span class="sd">            mode:[MetropolisHastings] McMC mode to use options are: MetropolisHastings</span>
<span class="sd">            alpha:[False] Default parameters for Markov chain steps, depend on transition probabilities</span>
<span class="sd">            trans_dimensional:[False] Boolean flag to run with trans-dimensional sampling</span>
<span class="sd">            learning_length:[10000] Number of samples for learning period and to discard from chain.</span>
<span class="sd">            parameterisation:[&#39;Tape&#39;] Source type parameterisation to use options are: Tape</span>
<span class="sd">            transition:[&#39;Gaussian&#39;] Transition pdf to use options are: &#39;Gaussian&#39;</span>
<span class="sd">            chain_length:[1000000] End point of the Markov chain.</span>
<span class="sd">            min_acceptance_rate:[0.3] Minimum targetted sample acceptance rate.</span>
<span class="sd">            max_acceptance_rate:[0.5] Maximum targetted sample acceptance rate.</span>
<span class="sd">            acceptance_rate_window:[1000] Number of samples to use in learning period for calculating and</span>
<span class="sd">                modifying the acceptance rate.</span>
<span class="sd">            initial_sample:[&#39;Grid&#39;] Initialisation sampling mode to use options are &#39;Grid&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">            McMC sampling object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">algorithm_names</span><span class="p">,</span> <span class="n">algorithms</span><span class="p">)</span> <span class="o">=</span> <span class="n">get_extensions</span><span class="p">(</span><span class="s1">&#39;MTfit.directed_algorithms&#39;</span><span class="p">)</span>
        <span class="c1"># McMC algorithms included in this file</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;metropolis_hastings&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">parameterisation</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;tape&#39;</span> <span class="ow">and</span> <span class="n">transition</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
            <span class="n">number_samples</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;number_samples&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">number_samples</span><span class="p">:</span>  <span class="c1"># or kwargs.get(&#39;multiple_events&#39;,False):</span>
                <span class="k">if</span> <span class="n">trans_dimensional</span><span class="p">:</span>
                    <span class="n">dimension_jump_prob</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dimension_jump_prob&#39;</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">IterativeTransDMetropolisHastingsGaussianTape</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">learning_length</span><span class="o">=</span><span class="n">learning_length</span><span class="p">,</span>
                                                                         <span class="n">chain_length</span><span class="o">=</span><span class="n">chain_length</span><span class="p">,</span>
                                                                         <span class="n">min_acceptance_rate</span><span class="o">=</span><span class="n">min_acceptance_rate</span><span class="p">,</span>
                                                                         <span class="n">max_acceptance_rate</span><span class="o">=</span><span class="n">max_acceptance_rate</span><span class="p">,</span>
                                                                         <span class="n">initial_sample</span><span class="o">=</span><span class="n">initial_sample</span><span class="p">,</span>
                                                                         <span class="n">acceptance_rate_window</span><span class="o">=</span><span class="n">acceptance_rate_window</span><span class="p">,</span>
                                                                         <span class="n">dimension_jump_prob</span><span class="o">=</span><span class="n">dimension_jump_prob</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># if kwargs.get(&#39;multiple_events&#39;, False):</span>
                    <span class="c1">#     return IterativeMultipleEventJointMetropolisHastingsGaussianTape(alpha=alpha, learning_length=learning_length,</span>
                    <span class="c1">#                                                                      chain_length=chain_length,</span>
                    <span class="c1">#                                                                      min_acceptance_rate=min_acceptance_rate,</span>
                    <span class="c1">#                                                                      max_acceptance_rate=max_acceptance_rate,</span>
                    <span class="c1">#                                                                      initial_sample=initial_sample,</span>
                    <span class="c1">#                                                                      acceptance_rate_window=acceptance_rate_window,</span>
                    <span class="c1">#                                                                      **kwargs)</span>
                    <span class="k">return</span> <span class="n">IterativeMetropolisHastingsGaussianTape</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">learning_length</span><span class="o">=</span><span class="n">learning_length</span><span class="p">,</span> <span class="n">chain_length</span><span class="o">=</span><span class="n">chain_length</span><span class="p">,</span>
                                                                   <span class="n">min_acceptance_rate</span><span class="o">=</span><span class="n">min_acceptance_rate</span><span class="p">,</span> <span class="n">max_acceptance_rate</span><span class="o">=</span><span class="n">max_acceptance_rate</span><span class="p">,</span>
                                                                   <span class="n">initial_sample</span><span class="o">=</span><span class="n">initial_sample</span><span class="p">,</span> <span class="n">acceptance_rate_window</span><span class="o">=</span><span class="n">acceptance_rate_window</span><span class="p">,</span>
                                                                   <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">trans_dimensional</span><span class="p">:</span>
                    <span class="n">dimension_jump_prob</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dimension_jump_prob&#39;</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">IterativeMultipleTryTransDMetropolisHastingsGaussianTape</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">learning_length</span><span class="o">=</span><span class="n">learning_length</span><span class="p">,</span>
                                                                                    <span class="n">chain_length</span><span class="o">=</span><span class="n">chain_length</span><span class="p">,</span>
                                                                                    <span class="n">min_acceptance_rate</span><span class="o">=</span><span class="n">min_acceptance_rate</span><span class="p">,</span>
                                                                                    <span class="n">max_acceptance_rate</span><span class="o">=</span><span class="n">max_acceptance_rate</span><span class="p">,</span>
                                                                                    <span class="n">initial_sample</span><span class="o">=</span><span class="n">initial_sample</span><span class="p">,</span>
                                                                                    <span class="n">acceptance_rate_window</span><span class="o">=</span><span class="n">acceptance_rate_window</span><span class="p">,</span>
                                                                                    <span class="n">dimension_jump_prob</span><span class="o">=</span><span class="n">dimension_jump_prob</span><span class="p">,</span>
                                                                                    <span class="n">number_samples</span><span class="o">=</span><span class="n">number_samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">IterativeMultipleTryMetropolisHastingsGaussianTape</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">learning_length</span><span class="o">=</span><span class="n">learning_length</span><span class="p">,</span>
                                                                              <span class="n">chain_length</span><span class="o">=</span><span class="n">chain_length</span><span class="p">,</span>
                                                                              <span class="n">min_acceptance_rate</span><span class="o">=</span><span class="n">min_acceptance_rate</span><span class="p">,</span>
                                                                              <span class="n">max_acceptance_rate</span><span class="o">=</span><span class="n">max_acceptance_rate</span><span class="p">,</span>
                                                                              <span class="n">initial_sample</span><span class="o">=</span><span class="n">initial_sample</span><span class="p">,</span>
                                                                              <span class="n">acceptance_rate_window</span><span class="o">=</span><span class="n">acceptance_rate_window</span><span class="p">,</span>
                                                                              <span class="n">number_samples</span><span class="o">=</span><span class="n">number_samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Extension options - Pass all arguments through</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">algorithm_names</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">algorithms</span><span class="p">[</span><span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()](</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">trans_dimensional</span><span class="o">=</span><span class="n">trans_dimensional</span><span class="p">,</span> <span class="n">learning_length</span><span class="o">=</span><span class="n">learning_length</span><span class="p">,</span>
                                            <span class="n">parameterisation</span><span class="o">=</span><span class="n">parameterisation</span><span class="p">,</span> <span class="n">transition</span><span class="o">=</span><span class="n">transition</span><span class="p">,</span> <span class="n">chain_length</span><span class="o">=</span><span class="n">chain_length</span><span class="p">,</span>
                                            <span class="n">min_acceptance_rate</span><span class="o">=</span><span class="n">min_acceptance_rate</span><span class="p">,</span> <span class="n">max_acceptance_rate</span><span class="o">=</span><span class="n">max_acceptance_rate</span><span class="p">,</span>
                                            <span class="n">acceptance_rate_window</span><span class="o">=</span><span class="n">acceptance_rate_window</span><span class="p">,</span> <span class="n">initial_sample</span><span class="o">=</span><span class="n">initial_sample</span><span class="p">,</span>
                                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Defaults</span>
            <span class="k">return</span> <span class="n">IterativeMetropolisHastingsGaussianTape</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">learning_length</span><span class="o">=</span><span class="n">learning_length</span><span class="p">,</span> <span class="n">chain_length</span><span class="o">=</span><span class="n">chain_length</span><span class="p">,</span>
                                                           <span class="n">min_acceptance_rate</span><span class="o">=</span><span class="n">min_acceptance_rate</span><span class="p">,</span> <span class="n">max_acceptance_rate</span><span class="o">=</span><span class="n">max_acceptance_rate</span><span class="p">,</span>
                                                           <span class="n">acceptance_rate_window</span><span class="o">=</span><span class="n">acceptance_rate_window</span><span class="p">,</span>
                                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MarginalisedMarkovChainMonteCarlo</span><span class="p">(</span><span class="n">BaseAlgorithm</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Marginalised Markov chain Monte Carlo Algorithm</span>

<span class="sd">    Markov chain constructed from marginalised MT dist (p(M) not p(M|A), i.e. marginalised over station parameters.</span>

<span class="sd">    Default object with basic functions added</span>

<span class="sd">    This is a child class of the BaseAlgorithm</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Returns zero for testing - should be set in __init__</span>
    <span class="n">default_sampling_priors</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;uniform_prior&#39;</span><span class="p">:</span> <span class="n">zero_prior</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialisation of marginalised Markov chain Monte Carlo Algorithm</span>

<span class="sd">        Keyword Args</span>
<span class="sd">            alpha:[1] Default parameters for Markov chain steps, depend on transition probabilities</span>
<span class="sd">            learning_length:[10000] Number of samples for learning period and to discard from chain.</span>
<span class="sd">            min_acceptance_rate:[0.3] Minimum targetted sample acceptance rate.</span>
<span class="sd">            max_acceptance_rate:[0.5] Maximum targetted sample acceptance rate.</span>
<span class="sd">            acceptance_rate_window:[100] Number of samples to use in learning period for calculating and modifying the acceptance rate.</span>
<span class="sd">            max_alpha:[100] Maximum values for alpha to take.</span>
<span class="sd">            sampling_prior:[&#39;uniform_prior&#39;] String to select the prior to use - the default is the uniform prior (Uniform over 6-sphere surface, not parameterisation).</span>
<span class="sd">            initial_sample:[None] Initial sample can be set if determined by some other method.</span>
<span class="sd">            diagnostic_output:[False] Set algorithm to output all information on iterations - for testing/plotting and debugging.</span>
<span class="sd">            min_number_initialisation_samples:[30000] Minimum number of samples for grid based iteration sampler.</span>
<span class="sd">            number_samples:[10000] Number of samples to use for each iteration of the grid sampler.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MarginalisedMarkovChainMonteCarlo</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mcmc</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number_samples</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tried</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_accepted</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Number of learning samples accepted</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_number_learning_accepted</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_number_initialisation_samples</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min_number_initialisation_samples&#39;</span><span class="p">,</span> <span class="mi">30000</span><span class="p">)</span>
        <span class="c1"># Handle initial sampling - either random sampling or single</span>
        <span class="c1"># sampling/initial sample.</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;initial_sample&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;grid&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span> <span class="o">=</span> <span class="n">IterationSample</span><span class="p">(</span><span class="n">number_samples</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;number_samples&#39;</span><span class="p">,</span> <span class="mi">10000</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialising</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_number_initialisation_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialising</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;initial_sample&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Default attribute initialisation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_alpha&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning_length</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;learning_length&#39;</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_acceptance_rate</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min_acceptance_rate&#39;</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_old_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_acceptance_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_acceptance_rate</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_acceptance_rate&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate_window</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;acceptance_rate_window&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;diagnostic_output&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_nonzero</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_initialisation_probability</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_max_mt</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_dc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Debug flag - adds learning samples and learning results etc to output</span>
        <span class="c1"># (large data size)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bis&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">))),</span> <span class="p">[]],</span> <span class="s1">&#39;bit&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;bir&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;cs&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">))),</span> <span class="p">[]]}</span>
        <span class="c1"># Sets prior function as uniform prior</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor_i</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Multiple events</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pdf_sample</span> <span class="o">=</span> <span class="n">Sample</span><span class="p">(</span><span class="n">number_events</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">)</span>
            <span class="n">all_alpha</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">dc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dc</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">):</span>
                <span class="n">all_alpha</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p_dc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">all_alpha</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_init_max_mt</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_max_initialisation_probability</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_init_nonzero</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span><span class="o">.</span><span class="n">number_events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">total_number_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tried</span>

    <span class="k">def</span> <span class="nf">acceptance_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets acceptance rate.</span>

<span class="sd">        Returns</span>
<span class="sd">            float: acceptance rate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_learning_accepted</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_length</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tried</span><span class="p">:</span>
                <span class="n">rate</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="p">))</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accepted</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tried</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="n">rate</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">rate</span>

    <span class="k">def</span> <span class="nf">_get_acceptance_rate_modifier</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets values for modifying alpha and hence acceptance rate.</span>

<span class="sd">        Returns</span>
<span class="sd">            float: ratio of actual rate to min or max targetted acceptance rate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">rate</span> <span class="ow">and</span> <span class="n">rate</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rate</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_acceptance_rate</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_old_rate</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_acceptance_rate</span> <span class="ow">and</span> <span class="n">rate</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_rate</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_rate</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_acceptance_rate</span><span class="p">:</span>
                    <span class="n">rate</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="n">rate</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">min_acceptance_rate</span>
            <span class="k">elif</span> <span class="n">rate</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_acceptance_rate</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_old_rate</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_acceptance_rate</span> <span class="ow">and</span> <span class="n">rate</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_rate</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_rate</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_acceptance_rate</span><span class="p">:</span>
                    <span class="n">rate</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="n">rate</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">max_acceptance_rate</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ratio</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rate</span> <span class="ow">and</span> <span class="n">rate</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_old_rate</span> <span class="o">=</span> <span class="n">rate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_old_ratio</span> <span class="o">=</span> <span class="n">ratio</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_old_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_old_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_old_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
        <span class="k">if</span> <span class="n">rate</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># revert to old alpha and change ratio</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_alpha</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># list</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_alpha</span><span class="p">[:]</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_old_ratio</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_old_ratio</span> <span class="o">=</span> <span class="n">ratio</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">rate</span><span class="p">:</span>
            <span class="c1"># revert to old alpha and change ratio</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_alpha</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># list</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_alpha</span><span class="p">[:]</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_ratio</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_old_ratio</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_old_ratio</span> <span class="o">=</span> <span class="n">ratio</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">ratio</span>

    <span class="k">def</span> <span class="nf">output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns output dictionary</span>

<span class="sd">        Returns</span>
<span class="sd">            dict: Output dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;discard&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
        <span class="n">output</span><span class="p">,</span> <span class="n">output_string</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">MarginalisedMarkovChainMonteCarlo</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;acceptance_rate&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate</span><span class="p">()})</span>
        <span class="n">output</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;accepted&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accepted</span><span class="p">})</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">output</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">})</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="n">output</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;debug_output&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">})</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;ln_bayesian_evidence&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">output_string</span>

    <span class="k">def</span> <span class="nf">_modify_acceptance_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">non_zero_percentage</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjusts the acceptance rate parameters based on the targetted acceptance rate.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">non_zero_percentage</span><span class="p">:</span>
            <span class="c1"># Modifies alpha by initial non-zero percentage from initialising</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">non_zero_percentage</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_acceptance_rate_modifier</span><span class="p">()</span>
        <span class="c1"># ratio=min(ratio,2.0)#sanity check bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_modify_alpha</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="n">ratio</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_modify_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">ratio</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modifies the transition PDF parameters based on the ratio argument</span>
<span class="sd">        The alpha argument is increased up to some max_alpha value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">newAlpha</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">alpha</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;gamma_dc&#39;</span><span class="p">,</span> <span class="s1">&#39;delta_dc&#39;</span><span class="p">,</span> <span class="s1">&#39;proposal_normalisation&#39;</span><span class="p">]:</span>
                    <span class="n">newAlpha</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">*</span><span class="n">ratio</span>
                    <span class="k">if</span> <span class="n">newAlpha</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_alpha</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                        <span class="n">newAlpha</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">newAlpha</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">alph</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">alpha</span><span class="p">):</span>
                <span class="n">newAlpha</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_modify_alpha</span><span class="p">(</span><span class="n">alph</span><span class="p">,</span> <span class="n">ratio</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newAlpha</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">*</span><span class="n">ratio</span>
            <span class="k">if</span> <span class="n">newAlpha</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_alpha</span><span class="p">:</span>
                <span class="n">newAlpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="k">return</span> <span class="n">newAlpha</span>

    <span class="k">def</span> <span class="nf">transition_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates transition probability for x and x1</span>

<span class="sd">        Returns</span>
<span class="sd">            float: transition probability</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">prior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates prior probability for x</span>

<span class="sd">        Returns</span>
<span class="sd">            float: prior probability</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prior</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">new_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates new sample</span>

<span class="sd">        Returns</span>
<span class="sd">            New sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">acceptance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ln_likelihoodx</span><span class="p">,</span> <span class="n">dc_prior</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate acceptance for x given ln_likelihoodx</span>

<span class="sd">        Args</span>
<span class="sd">            x: Model values</span>
<span class="sd">            ln_likelihoodx: Model ln_likelihood.</span>

<span class="sd">        Returns</span>
<span class="sd">            float:acceptance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_acceptance_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">scale_factori_1</span><span class="p">,</span> <span class="n">dc_prior</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate acceptance&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance</span><span class="p">(</span><span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">dc_prior</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">scale_factori_1</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{},</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">learning_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if still in learning period&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_learning_accepted</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_length</span>

    <span class="k">def</span> <span class="nf">_add_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add old result (not accepting test result)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">():</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;bis&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;cs&#39;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor_i</span><span class="p">)</span>
        <span class="c1"># Not adding to accepted, as want length of unique samples for chain</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">():</span>
            <span class="c1"># add a zero to learning acceptance list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">scale_factori_1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add new result (accepting new value)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">():</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;bis&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;cs&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="n">xi_1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add</span><span class="p">(</span><span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">scale_factori_1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_accepted</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_number_learning_accepted</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">scale_factori_1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add result xi_1 with ln_pdf ln_pi_1&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="o">=</span> <span class="n">xi_1</span>  <span class="c1"># Set new sample to old sample</span>
        <span class="c1"># set old ln_likelihood to new ln_likelihood</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">)</span>
        <span class="c1"># MULTIPLE_EVENTS</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">):</span>
                <span class="k">if</span> <span class="s1">&#39;gamma&#39;</span> <span class="ow">in</span> <span class="n">xi</span> <span class="ow">and</span> <span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">():</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">p_dc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">elif</span> <span class="s1">&#39;gamma&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p_dc</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dc</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dc</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor_i</span> <span class="o">=</span> <span class="n">scale_factori_1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pdf_sample</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="n">xi_1</span><span class="p">),</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">scale_factori_1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tried</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">iterate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate from result</span>

<span class="sd">        Args</span>
<span class="sd">            result: Result dictionary from forward task (e.g. MTfit.inversion.ForwardTask)</span>

<span class="sd">        Returns</span>
<span class="sd">            new_sample,End where End is a boolean flag to end the chain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Check if in initialisation stage</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialising</span><span class="p">:</span>
                <span class="c1"># Check number samples with max prob.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">maximum_initialisation_probability</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">u</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_initialisation_probability</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">maximum_initialisation_probability</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_initialisation_probability</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="c1"># Multiple events</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">individual_result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
                        <span class="n">ln_pdf</span> <span class="o">=</span> <span class="n">individual_result</span><span class="p">[</span><span class="s1">&#39;ln_pdf&#39;</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_pdf</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                            <span class="n">ln_pdf</span> <span class="o">=</span> <span class="n">LnPDF</span><span class="p">(</span><span class="n">ln_pdf</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ln_pdf</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_init_nonzero</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ln_pdf</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())</span>
                            <span class="c1"># Check if number of initialisation samples&lt;desired</span>
                            <span class="c1"># number or if there are no non-zero probability</span>
                            <span class="c1"># samples</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_initialisation_samples</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_number_initialisation_samples</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">maximum_initialisation_probability</span><span class="p">:</span>
                                <span class="c1"># Update max_prob/mt combinations for each</span>
                                <span class="c1"># event</span>
                                <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">ln_pdf</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ln_pdf</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_initialisation_probability</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_max_initialisation_probability</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ln_pdf</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ln_pdf</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_init_max_mt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">individual_result</span><span class="p">[</span><span class="s1">&#39;moment_tensors&#39;</span><span class="p">][:,</span> <span class="n">ln_pdf</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="c1"># Single event or full joint PDF initialisation</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ln_pdf</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;ln_pdf&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_pdf</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                        <span class="n">ln_pdf</span> <span class="o">=</span> <span class="n">LnPDF</span><span class="p">(</span><span class="n">ln_pdf</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ln_pdf</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_init_nonzero</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ln_pdf</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())</span>
                        <span class="c1"># Check if number of initialisation samples&lt;desired</span>
                        <span class="c1"># number or if there are no non-zero probability</span>
                        <span class="c1"># samples</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_initialisation_samples</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_number_initialisation_samples</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">maximum_initialisation_probability</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">ln_pdf</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ln_pdf</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_initialisation_probability</span><span class="p">:</span>
                                <span class="c1"># Update max_prob/mt combinations for the event</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_max_initialisation_probability</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ln_pdf</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ln_pdf</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
                                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;moment_tensors&#39;</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_init_max_mt</span> <span class="o">=</span> <span class="p">[]</span>
                                    <span class="k">for</span> <span class="n">mt</span> <span class="ow">in</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;moment_tensors&#39;</span><span class="p">]:</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">_init_max_mt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mt</span><span class="p">[:,</span> <span class="n">ln_pdf</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_init_max_mt</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;moment_tensors&#39;</span><span class="p">][:,</span> <span class="n">ln_pdf</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="c1"># Do quality check and chek if init_max p&gt;0</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">maximum_initialisation_probability</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">u</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_initialisation_probability</span><span class="p">])</span>
                    <span class="n">quality_check_ok</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="mi">100</span><span class="o">*</span><span class="nb">float</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_number_initialisation_samples</span><span class="p">)</span> <span class="o">&gt;</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">quality_check</span> <span class="k">for</span> <span class="n">nz</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_nonzero</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">maximum_initialisation_probability</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_initialisation_probability</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                    <span class="n">quality_check_ok</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_nonzero</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_number_initialisation_samples</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">quality_check</span>
                <span class="c1"># Check if number of initialisation samples&gt;desired number and</span>
                <span class="c1"># there are non-zero prob samples</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_initialisation_samples</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_number_initialisation_samples</span> <span class="ow">and</span> <span class="n">maximum_initialisation_probability</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quality_check</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quality_check</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">quality_check</span><span class="p">)</span> <span class="ow">and</span> <span class="n">quality_check_ok</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span><span class="s2">&quot;Data Error: Non-zero sample percentage above </span><span class="si">{}</span><span class="s2">%&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quality_check</span><span class="p">))</span>
                    <span class="c1"># Have solutions - initialising finished</span>
                    <span class="c1"># ADD LOGIC FOR PERCENTAGE NON-ZERO</span>
                    <span class="c1"># Need to get and keep track of number of samples</span>
                    <span class="c1"># Get percentage non-zero for initialisation and modify the alpha0 values appropriately -</span>
                    <span class="c1">#   Large % larger alpha</span>
                    <span class="c1">#   Small % smaller alpha</span>
                    <span class="c1">#</span>
                    <span class="c1"># Simplest is probably to just multiply by decimal of non-zero samples if multiple events</span>
                    <span class="c1"># self._modify_acceptance_rate(float(self._init_nonzero)/float(self._number_initialisation_samples))</span>
                    <span class="c1"># ADDED DJP 1/9/14 - check values  - killed as alpha large already</span>
                    <span class="c1">#</span>
                    <span class="c1"># Convert initial sample</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_max_mt</span><span class="p">)</span>
                    <span class="c1"># Initialise samples</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>
                    <span class="c1"># As this will always be accepted as initial sample</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_tried</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="c1"># Set ln_likelihood so accepted</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor_i</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_initialising</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="c1"># Print initialisation output</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span><span class="p">:</span>
                        <span class="n">nonzero_events</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nonzero</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_nonzero</span><span class="p">):</span>
                            <span class="n">nonzero_events</span> <span class="o">+=</span> <span class="s1">&#39;Event </span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1">% -&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="nb">float</span><span class="p">(</span><span class="n">nonzero</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_number_initialisation_samples</span><span class="p">))[:</span><span class="mi">3</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">nonzero_events</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_nonzero</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_number_initialisation_samples</span><span class="p">))[:</span><span class="mi">3</span><span class="p">])</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Algorithm initialised (Percentage non-zero - </span><span class="si">{}</span><span class="s1">) - Starting learning period</span><span class="se">\n</span><span class="s1">---------&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nonzero_events</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="c1"># Debug output (large data size)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="s1">&#39;bis&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="s1">&#39;bis&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_max_mt</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># Set t0 after initialisation</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">),</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialise</span><span class="p">()</span>
            <span class="c1"># Not in initialisation - main McMC part</span>
            <span class="c1"># Check for non-zero MT solutions</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;ln_pdf&#39;</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;ln_pdf&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                <span class="n">ln_pi_1</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;ln_pdf&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                    <span class="n">ln_pi_1</span> <span class="o">=</span> <span class="n">LnPDF</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">)</span>
                <span class="c1"># assume marginalised</span>
                <span class="c1"># Check acceptance (multiple tried events possible) returns</span>
                <span class="c1"># accepted sample or empty dict if none accepted</span>
                <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">scale_factor_i</span><span class="p">,</span> <span class="n">tried</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_acceptance_check</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;scale_factor&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
                <span class="c1"># returns dict not array/list of arrays</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi_1</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">xi_1</span><span class="p">])):</span>
                    <span class="c1"># Handling for multiple tries (agnostic)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tried</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="c1"># Add old samples for tried but not accepted samples</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_add_old</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_new</span><span class="p">(</span><span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">scale_factor_i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Handling for multiple tries (agnostic)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tried</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="c1"># Add old samples for tried but not accepted samples</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_add_old</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_old</span><span class="p">()</span>  <span class="c1"># Add old sample as non-accepted</span>
            <span class="c1"># Check if need to do learning transition PDF update</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate_window</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_modify_acceptance_rate</span><span class="p">()</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Learning </span><span class="si">{:.4f}% c</span><span class="s1">omplete - this learning iteration: </span><span class="si">{}</span><span class="s1"> accepted and </span><span class="si">{}</span><span class="s1">  tried - acceptance rate: </span><span class="si">{:.6f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_number_learning_accepted</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_length</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate</span><span class="p">()))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>  <span class="c1"># Append rate info to Debug output</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="s1">&#39;bir&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span>
                        <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate_window</span><span class="p">:]))</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate_window</span><span class="p">:]))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_debug_output</span><span class="p">[</span><span class="s1">&#39;bit&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">tx</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tx</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Not in learning</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tried</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># First sample</span>
                    <span class="c1"># Check and modify transition PDF parameters if within 25%</span>
                    <span class="c1"># of the acceptance_rate_window</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate_window</span><span class="p">:])</span> <span class="o">&gt;</span> <span class="mf">0.75</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate_window</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="p">[</span>
                            <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate_window</span><span class="p">:]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_modify_acceptance_rate</span><span class="p">()</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Learning complete - this learning iteration: </span><span class="si">{}</span><span class="s1"> accepted and </span><span class="si">{}</span><span class="s1"> tried - acceptance rate: </span><span class="si">{:.6f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_learning_accepted</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate</span><span class="p">()))</span>
                    <span class="c1"># Print out initialisation completion</span>
                    <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Learning elapsed time: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">))</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Starting main inversion</span><span class="se">\n</span><span class="s2">---------&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">t1</span>
                    <span class="c1"># Add sample (added to saved chain)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor_i</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tried</span> <span class="o">%</span> <span class="mi">100</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> samples tried: </span><span class="si">{}</span><span class="s1"> samples accepted&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tried</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accepted</span><span class="p">))</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_sample</span><span class="p">(),</span> <span class="kc">False</span>
        <span class="c1"># Error handling</span>
        <span class="k">except</span> <span class="ne">MemoryError</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Memory Error, forcing garbage collection and trying again&#39;</span><span class="p">)</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="n">DataError</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;Error with data&#39;</span><span class="p">)</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">initialise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialse samples</span>

<span class="sd">        Initialises the chain either using an initialiser if set, otherwise using random_sample.</span>

<span class="sd">        Returns</span>
<span class="sd">            new_sample,False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialiser - use initialise() function in the initialiser algorithm</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialising</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_number_initialisation_samples</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span><span class="o">.</span><span class="n">number_samples</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialiser</span><span class="o">.</span><span class="n">initialise</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span>
        <span class="c1"># Set initialse sample parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tried</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># As this will always be accepted as initial sample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor_i</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">),</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_convert_sample_single</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts single event sample to MT form</span>

<span class="sd">        Args</span>
<span class="sd">            x: sample</span>

<span class="sd">        Returns</span>
<span class="sd">            Converted Sample</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts sample to MT form</span>

<span class="sd">        Args</span>
<span class="sd">            x: sample</span>

<span class="sd">        Returns</span>
<span class="sd">            Converted Sample</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="o">*</span><span class="mi">6</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;shape of x &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; must match the number of events&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># dict(zip([&#39;gamma&#39;,&#39;delta&#39;,&#39;kappa&#39;,&#39;h&#39;,&#39;sigma&#39;],MT6_Tape(x)))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_sample_single</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">):</span>
                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert_sample_single</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">6</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">6</span><span class="p">,</span> <span class="p">:]))</span>
            <span class="k">return</span> <span class="n">data</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">X</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert_sample_single</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_sample_single</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MarginalisedMetropolisHastings</span><span class="p">(</span><span class="n">MarginalisedMarkovChainMonteCarlo</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Marginalised Metropolis Hastings Markov chain Monte Carlo Algorithm</span>

<span class="sd">    Markov chain constructed using the Metropolis Hastings method from the marginalised PDF (p(M) not p(M|A), i.e. marginalised over station parameters.</span>

<span class="sd">    This is a child class of the MarginalisedMarkovChainMonteCarlo</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">acceptance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ln_likelihood_x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates acceptance</span>

<span class="sd">        Calculates the acceptance from the Metropolis condition.</span>

<span class="sd">        Args</span>
<span class="sd">            x: Model values</span>
<span class="sd">            ln_likelihood_x: Model ln_likelihood.</span>

<span class="sd">        Returns</span>
<span class="sd">            float:acceptance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">LnPDF</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_likelihood_x</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">LnPDF</span><span class="p">)):</span>
            <span class="n">ln_likelihood_x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ln_likelihood_x</span><span class="p">)</span>
        <span class="c1"># Handle multiple events</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[:]</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">_numerator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_pdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">_denominator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">acc</span> <span class="o">*=</span> <span class="n">_numerator</span><span class="o">/</span><span class="n">_denominator</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[:]</span>
                    <span class="c1"># 0 probability values for acceptance denominator so acc is</span>
                    <span class="c1"># infinite --&gt; set to 1</span>
                    <span class="k">return</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[:]</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">acc</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ln_likelihood_x</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># ln likelihoods</span>
            <span class="n">acceptance</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transition_pdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transition_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">))</span>
            <span class="n">acceptance</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ln_likelihood_x</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">acceptance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 0 probability values for acceptance denominator so acc is</span>
            <span class="c1"># infinite --&gt; set to 1</span>
            <span class="k">return</span> <span class="mi">1</span>


<span class="k">class</span> <span class="nc">MarginalisedMetropolisHastingsGaussianTape</span><span class="p">(</span><span class="n">MarginalisedMetropolisHastings</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Marginalised Metropolis Hastings Markov chain Monte Carlo Algorithm using Gaussian transition PDF and Tape and Tape parameterisation</span>

<span class="sd">    Markov chain constructed using the Metropolis Hastings method from the marginalised pdf (p(M) not p(M|A), i.e. marginalised over station parameters.</span>
<span class="sd">    The transition pdf is gaussian and the parameterisation is from Tape and Tape (A geometric setting for moment tensors, Tape and Tape, 2012, GJI 190 pp 476-490).</span>

<span class="sd">    This is a child class of the MarginalisedMetropolisHastings</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialisation of marginalised Metropolis Hastings Markov chain Monte Carlo Algorithm using gaussian transition pdf and Tape source parameterisation.</span>

<span class="sd">        Keyword Args</span>
<span class="sd">            alpha: Default parameters for Markov chain steps, depend on transition probabilities Default parameters are:</span>
<span class="sd">                    {&#39;kappa&#39;:np.pi/5,&#39;h&#39;:0.2,&#39;sigma&#39;:np.pi/10,&#39;gamma&#39;:np.pi/15,</span>
<span class="sd">                     &#39;delta&#39;:np.pi/10,&#39;alpha&#39;:np.pi/10,&#39;poisson&#39;:0.2}</span>
<span class="sd">            max_alpha: Maximum values for alpha to take. Default parameters are:</span>
<span class="sd">                    {&#39;kappa&#39;:np.pi/2,&#39;h&#39;:0.5,&#39;sigma&#39;:np.pi/4,&#39;gamma&#39;:np.pi/12,&#39;delta&#39;:np.pi/4,</span>
<span class="sd">                     &#39;alpha&#39;:np.pi/4,&#39;poisson&#39;:0.1}</span>
<span class="sd">            poisson:[0.25] poisson ratio for CDC model.</span>
<span class="sd">            min_poisson:[-np.inf] Minimum poisson ratio for CDC model.</span>
<span class="sd">            max_poisson:[np.inf] Maximum poisson ratio for CDC model.</span>

<span class="sd">        This is a child class of the MarginalisedMetropolisHastings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_sampling_priors</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;uniform_prior&#39;</span><span class="p">:</span> <span class="n">uniform_prior</span><span class="p">,</span> <span class="s1">&#39;flat_prior&#39;</span><span class="p">:</span> <span class="n">flat_prior</span><span class="p">}</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MarginalisedMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;kappa&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">15</span><span class="p">,</span>
                      <span class="s1">&#39;delta&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;poisson&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">}</span>
        <span class="c1"># Set up alpha for multiple events</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">all_alpha</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">):</span>
                <span class="n">all_alpha</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">all_alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_alpha</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;kappa&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">12</span><span class="p">,</span>
                          <span class="s1">&#39;delta&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;poisson&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">}</span>
        <span class="c1"># Reflect PDFs off upper limit - maintains uniformity in transition PDF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_gamma</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reflect_gamma&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_delta</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reflect_delta&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_sigma</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reflect_sigma&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_dip</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reflect_dip&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="c1"># alpha is the opening crack angle in the CDC model - it takes values</span>
        <span class="c1"># from -pi/2 to pi/2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reflect_alpha&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="c1"># N.B. reflecting works because</span>
        <span class="c1"># Poisson parameters for CDC solution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poisson</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;poisson&#39;</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_poisson</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_poisson&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_poisson</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min_poisson&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transition_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">dc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basic_cdc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates gaussian transition pdf</span>

<span class="sd">        Evaluates the gaussian transition probability for x and x1</span>

<span class="sd">        Returns</span>
<span class="sd">            float: transition probability</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Gaussian makes transition PDF symmetrical but some parameters can be</span>
        <span class="c1"># truncated parameters (gamma,delta,h,sigma)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc</span>
            <span class="k">if</span> <span class="n">basic_cdc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">basic_cdc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_cdc</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dc</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">basic_cdc</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_gamma</span><span class="p">:</span>
                    <span class="n">_numerator</span> <span class="o">=</span> <span class="n">gaussian_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">])</span>
                    <span class="n">_denominator</span> <span class="o">=</span> <span class="n">gaussian_cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">])</span><span class="o">-</span><span class="n">gaussian_cdf</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">])</span>
                    <span class="n">p</span> <span class="o">*=</span> <span class="n">_numerator</span><span class="o">/</span><span class="n">_denominator</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_delta</span><span class="p">:</span>
                    <span class="n">_numerator</span> <span class="o">=</span> <span class="n">gaussian_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">])</span>
                    <span class="n">_denominator</span> <span class="o">=</span> <span class="n">gaussian_cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">])</span><span class="o">-</span><span class="n">gaussian_cdf</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">])</span>
                    <span class="n">p</span> <span class="o">*=</span> <span class="n">_numerator</span><span class="o">/</span><span class="n">_denominator</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_cdc</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_alpha</span><span class="p">:</span>
                <span class="c1"># alpha is opening angle as parameter</span>
                <span class="n">_numerator</span> <span class="o">=</span> <span class="n">gaussian_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">])</span>
                <span class="n">_denominator</span> <span class="o">=</span> <span class="n">gaussian_cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">])</span><span class="o">-</span><span class="n">gaussian_cdf</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">])</span>
                <span class="n">p</span> <span class="o">*=</span> <span class="n">_numerator</span><span class="o">/</span><span class="n">_denominator</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_dip</span><span class="p">:</span>
                <span class="n">_numerator</span> <span class="o">=</span> <span class="n">gaussian_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">])</span>
                <span class="n">_denominator</span> <span class="o">=</span> <span class="n">gaussian_cdf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">])</span><span class="o">-</span><span class="n">gaussian_cdf</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">])</span>
                <span class="n">p</span> <span class="o">*=</span> <span class="n">_numerator</span><span class="o">/</span><span class="n">_denominator</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_sigma</span><span class="p">:</span>
                <span class="n">_numerator</span> <span class="o">=</span> <span class="n">gaussian_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">])</span>
                <span class="n">_denominator</span> <span class="o">=</span> <span class="n">gaussian_cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">])</span><span class="o">-</span><span class="n">gaussian_cdf</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">])</span>
                <span class="n">p</span> <span class="o">*=</span> <span class="n">_numerator</span><span class="o">/</span><span class="n">_denominator</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_new_sample_single</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates new sample</span>

<span class="sd">        Generates a new sample by drawing a new sample from the gaussian transition pdf, conditional on the previous sample.</span>

<span class="sd">        Returns</span>
<span class="sd">            New sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_cdc</span><span class="p">:</span>
            <span class="n">xi_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]))</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">xi_alpha</span>
            <span class="k">while</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="ow">or</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_alpha</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
                        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">a</span>
                    <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="n">a</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">xi_alpha</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">poisson</span><span class="p">:</span>
                <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">basic_cdc_GD</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">poisson</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tanphi</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]))</span>
                <span class="n">xi_poisson</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">tanphi</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">tanphi</span><span class="p">)</span>
                <span class="c1"># handle sampling for poisson</span>
                <span class="n">poisson</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;poisson&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">xi_poisson</span>
                <span class="k">while</span> <span class="n">poisson</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_poisson</span> <span class="ow">or</span> <span class="n">poisson</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_poisson</span><span class="p">:</span>
                    <span class="n">poisson</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;poisson&#39;</span><span class="p">]</span> <span class="o">*</span> \
                        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">xi_poisson</span>
                <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">basic_cdc_GD</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">poisson</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_gamma</span><span class="p">:</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span>
            <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_delta</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span>
            <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
        <span class="c1"># since strike 2*pi=strike 0 wrap round</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;kappa&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;kappa&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;kappa&#39;</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># wrap h round and change strike by pi</span>
            <span class="c1"># h&lt;0 slip changes</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_dip</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">h</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># no wrap -redraw</span>
                <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">]</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span>
        <span class="c1"># tape parameterisation limits s to -pi/2 to pi/2</span>
        <span class="c1"># This parameterisation does not wrap in this range - wraps over 2*pi</span>
        <span class="c1"># can however wrap sdr to other sdr pair that have rake in valid sigma range</span>
        <span class="c1">#</span>
        <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reflect_sigma</span><span class="p">:</span>
                <span class="c1"># If trying to wrap would be</span>
                <span class="c1"># [k,d,s]=SDR_SDR(x[&#39;kappa&#39;],np.arccos(x[&#39;h&#39;]),s)</span>
                <span class="c1"># x[&#39;kappa&#39;]=k</span>
                <span class="c1"># x[&#39;h&#39;]=np.cos(d)</span>
                <span class="c1"># alternativly can reflect the PDF instead</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">s</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">+</span><span class="n">s</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">new_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates new sample</span>

<span class="sd">        Can handle multiple events</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">all_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">all_x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expect self.xi to be list not </span><span class="si">{}</span><span class="se">\n</span><span class="s1"> self.xi = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">))</span>
            <span class="n">all_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">all_x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">all_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="n">all_x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_x</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">all_alpha</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new_sample_single</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="o">=</span> <span class="n">all_x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">all_alpha</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_sample_single</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_dc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if a sample x is double-couple&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_sample</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span>

    <span class="k">def</span> <span class="nf">_convert_sample_single</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts sample to and from tape parameterisation</span>

<span class="sd">        Args</span>
<span class="sd">            x: sample - can be a dict of Tape params -&gt; converted to MT or an MT -&gt; converted to a dict of Tape params</span>

<span class="sd">        Returns</span>
<span class="sd">            Converted Sample</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;gamma&#39;</span><span class="p">,</span> <span class="s1">&#39;delta&#39;</span><span class="p">,</span> <span class="s1">&#39;kappa&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span><span class="p">],</span> <span class="n">MT6_Tape</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Try c functions (quicker)</span>
            <span class="kn">from</span> <span class="nn">.cmarkov_chain_monte_carlo</span> <span class="k">import</span> <span class="n">convert_sample</span> <span class="k">as</span> <span class="n">c_convert_sample</span>
            <span class="k">return</span> <span class="n">c_convert_sample</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;kappa&#39;</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">MT33_MT6</span><span class="p">(</span><span class="n">Tape_MT33</span><span class="p">(</span><span class="o">**</span><span class="n">x</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_6sphere_random_mt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a random MT</span>

<span class="sd">        Generates a random MT using flat pdfs for each parameter.</span>

<span class="sd">        Returns</span>
<span class="sd">            Random MT in Tape parameterisation</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;kappa&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">random_dc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a random DC</span>

<span class="sd">        Generates a random DC using flat pdfs for each parameter (gamma=delta=0).</span>

<span class="sd">        Returns</span>
<span class="sd">            Random MT in Tape parameterisation</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;kappa&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">random_basic_cdc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a random C+DC</span>

<span class="sd">        Generates a random C+DC using flat pdfs for each parameter (gamma,delta given by alpha).</span>

<span class="sd">        Returns</span>
<span class="sd">            Random MT in Tape parameterisation</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">basic_cdc_GD</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">poisson</span><span class="p">)</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;kappa&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span>
        <span class="n">x</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">prior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basic_cdc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates prior probability for x</span>

<span class="sd">        Returns</span>
<span class="sd">            float: prior probability</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">basic_cdc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">basic_cdc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_cdc</span>
        <span class="n">max_poisson</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_poisson</span>
        <span class="n">min_poisson</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_poisson</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">MarginalisedMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">basic_cdc</span><span class="p">,</span> <span class="n">max_poisson</span><span class="p">,</span> <span class="n">min_poisson</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">IterativeMetropolisHastingsGaussianTape</span><span class="p">(</span><span class="n">MarginalisedMetropolisHastingsGaussianTape</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Metropolis-Hastings Markov chain Monte Carlo Algorithm using Gaussian Transition PDF and Tape parameterisation, chain length ends maximum length</span>

<span class="sd">    Algorithm ends when the number of samples in the chain equals the chain_length, where the chain length corresponds to the number of accepted samples.</span>
<span class="sd">    The parameterisation is from Tape and Tape (A geometric setting for moment tensors, Tape and Tape, 2012, GJI 190 pp 476-490).</span>

<span class="sd">    This is a child class of the MarginalisedMetropolisHastingsGaussianTape class</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialisation of Metropolis-Hastings Markov chain Monte Carlo Algorithm using Gaussian Transition PDF and Tape parameterisation, constrained by chain length</span>

<span class="sd">        The chain length corresponds to the number of accepted samples.</span>

<span class="sd">        Keyword Args</span>
<span class="sd">            chain_length:[1000000] Maximum length of the Markov chain.</span>

<span class="sd">        This is a child class of the MarginalisedMetropolisHastingsGaussianTape class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IterativeMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chain_length</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;chain_length&#39;</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iterate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate from result</span>

<span class="sd">        Args</span>
<span class="sd">            result: Result dictionary from forward task (e.g. MTfit.inversion.ForwardTask)</span>

<span class="sd">        Returns</span>
<span class="sd">            new_sample,End where End is a boolean flag to end the chain if the length of accepted samples is longer than the chain length.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">task</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">IterativeMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">iterate</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="c1"># Check chain length</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tried</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_length</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Chain complete</span><span class="se">\n</span><span class="s1">Chain elapsed time: </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_t1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">task</span><span class="p">,</span> <span class="n">end</span>


<span class="k">class</span> <span class="nc">IterativeTransDMetropolisHastingsGaussianTape</span><span class="p">(</span><span class="n">IterativeMetropolisHastingsGaussianTape</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trans-Dimensional Metropolis-Hastings Markov chain Monte Carlo Algorithm using Gaussian Transition PDF and Tape parameterisation, chain length ends maximum length</span>

<span class="sd">    Trans Dimensional sampling, jumping between double-couple and full moment tensor models.</span>
<span class="sd">    Algorithm ends when the number of samples in the chain equals the chain_length, where the chain length corresponds to the number of accepted samples.</span>
<span class="sd">    The parameterisation is from Tape and Tape (A geometric setting for moment tensors, Tape and Tape, 2012, GJI 190 pp 476-490).</span>

<span class="sd">    This is a child class of the IterativeMetropolisHastingsGaussianTape</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialisation of Trans-Dimensional Metropolis-Hastings Markov chain Monte Carlo Algorithm using Gaussian Transition PDF and Tape parameterisation, chain length ends maximum length</span>

<span class="sd">        Keyword Args</span>
<span class="sd">            dimension_jump_prob:[0.01] Probability of making a dimension jump.</span>
<span class="sd">            dc_sigma_g:[0.2] alpha parameter for the balance vector gamma parameter</span>
<span class="sd">            dc_sigma_d:[0.2] alpha parameter for the balance vector delta parameter</span>
<span class="sd">            dc_prior:[0.5] prior probability for the DC model</span>

<span class="sd">        This is a child class of the IterativeMetropolisHastingsGaussianTape</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IterativeTransDMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Update alpha with dc balance vector parameters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;gamma_dc&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">alpha</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;gamma_dc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dc_sigma_g&#39;</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;delta_dc&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">alpha</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;delta_dc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dc_sigma_d&#39;</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;gamma_dc&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;gamma_dc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dc_sigma_g&#39;</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;delta_dc&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;delta_dc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dc_sigma_d&#39;</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Set DC model prior</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dc_prior</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dc_prior&#39;</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">)</span>
        <span class="c1"># Calculate balance vector proposal normalisation</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
        <span class="n">pn</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">*</span><span class="n">gaussian_pdf</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dc_sigma_d&#39;</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span>
                 <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">d</span><span class="p">)))</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">gaussian_cdf</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dc_sigma_g&#39;</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">)))</span>
        <span class="c1"># Add proposal normalisation to alpha</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">:</span>
                <span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;proposal_normalisation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pn</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;proposal_normalisation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pn</span>
        <span class="c1"># Set jump options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension_jump_prob</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dimension_jump_prob&#39;</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_jump_params</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gaussian_jump_params&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_learning_dc_dc_accepted</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_learning_mt_mt_accepted</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_new_sample_single</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates new sample</span>

<span class="sd">        Generates a new sample by drawing a new sample from the gaussian transition pdf, conditional on the previous sample.</span>
<span class="sd">        Probability if the sample jumping between models given by the dimension_jump_prob kwarg on initialisation.</span>

<span class="sd">        Returns</span>
<span class="sd">            New sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set jump check</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension_jump_prob</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span><span class="p">:</span>
            <span class="c1"># new sample is same parameters but with or without gamma and delta</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">)</span>
            <span class="n">x</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;gamma&#39;</span><span class="p">)</span>
            <span class="n">x</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;delta&#39;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">x</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;g0&#39;</span><span class="p">)</span>
                <span class="n">x</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;d0&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">:</span>  <span class="c1"># dc to mt</span>
                <span class="c1"># set random gamma beta</span>
                <span class="n">gamma</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump_params</span><span class="p">()</span>
                <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gamma</span>
                <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># mt to dc (g0 and d0 set from gamma delta)</span>
                <span class="n">x</span><span class="p">[</span><span class="s1">&#39;g0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span>
                <span class="n">x</span><span class="p">[</span><span class="s1">&#39;d0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span>
                <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span> <span class="o">=</span> <span class="n">x</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Normal new sample</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">IterativeTransDMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_new_sample_single</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">jump_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates dimension jump parameters</span>

<span class="sd">        Calculates either the probabilities of the balancing parameters if x exists, else returns the two balancing parameters.</span>

<span class="sd">        Args</span>
<span class="sd">            x:[False] Can be given as the two balancing parameters</span>

<span class="sd">        Returns</span>
<span class="sd">            if x is not  False:</span>
<span class="sd">                float: q - probability of balancing parameters</span>
<span class="sd">            else:</span>
<span class="sd">                float: gamma - Randomly distributed gamma value</span>
<span class="sd">                float: delta - Randomly distributed delta value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If x is passed then this function returns the probability of</span>
        <span class="c1"># obtaining the two balance paraemters</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_jump_params</span><span class="p">:</span>
                <span class="c1"># corresponds to two normal pdfs about 0,0 with widths given by</span>
                <span class="c1"># sigma normalised over the lune</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">gaussian_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;gamma_dc&#39;</span><span class="p">])</span>
                <span class="n">q</span> <span class="o">*=</span> <span class="n">gaussian_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;delta_dc&#39;</span><span class="p">])</span>
                <span class="n">q</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;proposal_normalisation&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="mi">3</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>  <span class="c1"># Scaled uniform prob</span>
            <span class="k">return</span> <span class="n">q</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get jump params</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_jump_params</span><span class="p">:</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="c1"># Not wrapped/reflected</span>
                <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="p">:</span>
                    <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;gamma_dc&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">()</span>
                <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="s1">&#39;delta_dc&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
            <span class="k">return</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">delta</span>

    <span class="k">def</span> <span class="nf">acceptance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ln_likelihoodx</span><span class="p">,</span> <span class="n">dc_prior</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates acceptance</span>

<span class="sd">        Calculates the acceptance from the Trans-Dimensional Metropolis condition.</span>

<span class="sd">        Args</span>
<span class="sd">            x: Model values</span>
<span class="sd">            ln_likelihoodx: Model likelihood.</span>

<span class="sd">        Returns</span>
<span class="sd">            float:acceptance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">)</span>
        <span class="c1"># Handle jump parameters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">):</span>
            <span class="c1"># No jump - may have been accidentally picked up</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">IterativeTransDMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">acceptance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ln_likelihoodx</span><span class="p">)</span>
            <span class="c1"># dc to mt jump</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">)</span>
                <span class="n">xi</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;gamma&#39;</span><span class="p">)</span>
                <span class="n">xi</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;delta&#39;</span><span class="p">)</span>
                <span class="n">model_prior_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dc_prior</span><span class="p">)</span><span class="o">/</span><span class="n">dc_prior</span>
                <span class="c1"># LnLikelihoods    N.B&gt; self.jump_params(x) called as x</span>
                <span class="c1"># contains gamma delta generated using jump Params</span>
                <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jump_params</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="n">xi</span><span class="p">)))</span><span class="o">*</span><span class="n">model_prior_ratio</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ln_likelihoodx</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>  <span class="c1"># mt to dc jump</span>
                <span class="n">xp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">xp</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;gamma&#39;</span><span class="p">)</span>
                <span class="n">xp</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;delta&#39;</span><span class="p">)</span>
                <span class="n">model_prior_ratio</span> <span class="o">=</span> <span class="n">dc_prior</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dc_prior</span><span class="p">)</span>
                <span class="c1"># LnLikelihoods    N.B&gt; self.jump_params(self.xi) called as</span>
                <span class="c1"># self.xi contains gamma delta generated using jump Params</span>
                <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jump_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="n">xp</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">))</span><span class="o">*</span><span class="n">model_prior_ratio</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ln_likelihoodx</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># no jump may have been accidentally picked up</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">IterativeTransDMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">acceptance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ln_likelihoodx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">IterativeTransDMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">acceptance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ln_likelihoodx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iterate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterates new sample</span>

<span class="sd">        Calculates the acceptance and handles the pDC output</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">MTs</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">IterativeTransDMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">iterate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Print pDC output</span>
        <span class="k">if</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_dc</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Probability of dc: </span><span class="si">{:.6f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_dc</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_sample</span><span class="o">.</span><span class="n">ln_pdf</span><span class="p">))))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_dc</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pdc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_dc</span><span class="p">):</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Event - </span><span class="si">{}</span><span class="s1"> Probability of dc: </span><span class="si">{:.6f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">pdc</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_sample</span><span class="o">.</span><span class="n">ln_pdf</span><span class="p">))))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span><span class="p">:</span>
            <span class="c1"># check current sample</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dc</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">MTs</span><span class="p">,</span> <span class="n">end</span>

    <span class="k">def</span> <span class="nf">output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return output dict</span>

<span class="sd">        Return output dict including pDC value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span><span class="p">,</span> <span class="n">output_string</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">IterativeTransDMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;pDC&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_dc</span>
        <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">output_string</span>


<span class="k">class</span> <span class="nc">IterativeMultipleTryMetropolisHastingsGaussianTape</span><span class="p">(</span><span class="n">IterativeMetropolisHastingsGaussianTape</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Metropolis-Hastings Markov chain Monte Carlo Algorithm using Gaussian Transition PDF and Tape parameterisation, chain length ends maximum length</span>

<span class="sd">    Algorithm ends when the number of samples in the chain equals the chain_length, where the chain length corresponds to the number of accepted samples.</span>
<span class="sd">    The parameterisation is from Tape and Tape (A geometric setting for moment tensors, Tape and Tape, 2012, GJI 190 pp 476-490).</span>

<span class="sd">    This is a child class of the IterativeMetropolisHastingsGaussianTape</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialisation of Metropolis-Hastings Markov chain Monte Carlo Algorithm using Gaussian Transition PDF and Tape parameterisation, constrained by chain length</span>

<span class="sd">        The chain length corresponds to the number of accepted samples.</span>

<span class="sd">        Keyword Args</span>
<span class="sd">            number_samples:[1000] Maximum number of samples to try on each iteration. (unused samples are dropped)</span>

<span class="sd">        This is a child class of the IterativeMetropolisHastingsGaussianTape</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IterativeMultipleTryMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_number_samples</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;number_samples&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">min_acceptance_rate</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_number_samples</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">new_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">gaussian_jump</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get new samples including multiple samples to try&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Try c code</span>
            <span class="kn">from</span> <span class="nn">.cmarkov_chain_monte_carlo</span> <span class="k">import</span> <span class="n">new_samples</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">mt</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Multiple events</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">):</span>
                    <span class="n">xi_1</span><span class="p">,</span> <span class="n">mt_i</span> <span class="o">=</span> <span class="n">new_samples</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                             <span class="n">jump</span><span class="o">=</span><span class="n">jump</span><span class="p">,</span> <span class="n">gaussian_jump</span><span class="o">=</span><span class="n">gaussian_jump</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xi_1</span><span class="p">)</span>
                    <span class="n">mt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mt_i</span><span class="p">)</span>
            <span class="c1"># Single event</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">,</span> <span class="n">mt</span> <span class="o">=</span> <span class="n">new_samples</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="n">jump</span><span class="p">,</span>
                                            <span class="n">gaussian_jump</span><span class="o">=</span><span class="n">gaussian_jump</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mt</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># Use python code</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">IterativeMultipleTryMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">new_sample</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_acceptance_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">scale_factori_1</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check acceptance for multiple tries&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Try C code</span>
            <span class="kn">from</span> <span class="nn">.cmarkov_chain_monte_carlo</span> <span class="k">import</span> <span class="n">acceptance_check</span><span class="p">,</span> <span class="n">me_acceptance_check</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">LnPDF</span><span class="p">):</span>
                <span class="n">ln_pi_1</span> <span class="o">=</span> <span class="n">ln_pi_1</span><span class="o">.</span><span class="n">_ln_pdf</span>
            <span class="c1"># No non-zero samples</span>
            <span class="k">if</span> <span class="n">ln_pi_1</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                <span class="n">xi_1</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">ln_pi_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">xi_1</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">)]</span>
                <span class="n">ln_pi_1</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># If in learning, increase the number of test samples</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_number_samples</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span>
                        <span class="nb">int</span><span class="p">(</span><span class="mf">1.1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
                <span class="k">return</span> <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="o">.</span><span class="n">major</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">is_uniform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prior</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;uniform_prior&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">is_uniform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prior</span><span class="o">.</span><span class="n">func_name</span> <span class="o">==</span> <span class="s1">&#39;uniform_prior&#39;</span>
                <span class="c1"># Mutliple events</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;dc_prior&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dc_prior</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dc_prior</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">dc_prior</span><span class="p">])</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                        <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">me_acceptance_check</span><span class="p">(</span><span class="n">xi_1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                                                   <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">,</span> <span class="n">is_uniform</span><span class="p">,</span>
                                                                   <span class="n">gaussian_jump</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;gaussian_jump_params&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                                                                   <span class="n">dc_prior</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;dc_prior&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">])))</span>  <span class="c1"># dc prior ignored if not transd</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">me_acceptance_check</span><span class="p">(</span><span class="n">xi_1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="o">.</span><span class="n">_ln_pdf</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                                                   <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">,</span> <span class="n">is_uniform</span><span class="p">,</span>
                                                                   <span class="n">gaussian_jump</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;gaussian_jump_params&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                                                                   <span class="n">dc_prior</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;dc_prior&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">])))</span>
                <span class="c1"># Single events</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                        <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">acceptance_check</span><span class="p">(</span><span class="n">xi_1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                                                <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">,</span> <span class="n">is_uniform</span><span class="p">,</span>
                                                                <span class="n">gaussian_jump</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;gaussian_jump_params&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                                                                <span class="n">dc_prior</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;dc_prior&#39;</span><span class="p">,</span> <span class="mf">0.</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">acceptance_check</span><span class="p">(</span><span class="n">xi_1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="o">.</span><span class="n">_ln_pdf</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                                                <span class="bp">self</span><span class="o">.</span><span class="n">ln_likelihood_xi</span><span class="p">,</span> <span class="n">is_uniform</span><span class="p">,</span>
                                                                <span class="n">gaussian_jump</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;gaussian_jump_params&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                                                                <span class="n">dc_prior</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;dc_prior&#39;</span><span class="p">,</span> <span class="mf">0.</span><span class="p">))</span>
            <span class="c1"># No accepted samples, so increase the number of test samples if in</span>
            <span class="c1"># learning period</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_number_samples</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mf">1.1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_check</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">min</span><span class="p">([</span><span class="mi">120</span><span class="o">*</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span><span class="p">)])</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span><span class="p">:</span>
                <span class="c1"># Handle too many samples</span>
                <span class="c1"># Probability of having accepted sample within index is</span>
                <span class="c1">#</span>
                <span class="c1">#   P(x&lt;=j)=1-(1-r)^j</span>
                <span class="c1">#</span>
                <span class="c1"># where r is the probability of accepting a sample and j is the accepted sample index</span>
                <span class="c1"># Solving for this given r~1/number_samples for P=0.01 gives j~0.01*number_samples</span>
                <span class="c1"># Consequently, the index of the accepted sample has a probability of 0.01 of being &lt; 0.01*number_samples (given the number_samples -&gt; r estimate)</span>
                <span class="c1"># The factor of 120 is a fudge to account for uncertainties</span>
                <span class="c1"># (this can help prevent calculating too many forward models)</span>
                <span class="c1"># max prevents 0 for _number_samples</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="mi">120</span><span class="o">*</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span><span class="p">)])</span>
            <span class="c1"># Accepted sample with scale_factor (relative inversion)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale_factori_1</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">scale_factori_1</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">index</span>
            <span class="k">return</span> <span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">index</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># Python code</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;Cython Error&#39;</span><span class="p">)</span>
            <span class="c1"># Non-zero samples</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">ln_pi_1</span> <span class="o">=</span> <span class="n">ln_pi_1</span><span class="o">.</span><span class="n">_ln_pdf</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                <span class="c1"># Loop over samples</span>
                <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">_xi_1</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xi_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">):</span>
                                <span class="n">_xi_1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xi_1</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">_xi_1</span> <span class="o">=</span> <span class="n">xi_1</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xi_1</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                            <span class="n">_xi_1</span> <span class="o">=</span> <span class="n">xi_1</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">_xi_1</span> <span class="o">=</span> <span class="n">xi_1</span>
                    <span class="c1"># Get acceptance result</span>
                    <span class="n">oxi_1</span><span class="p">,</span> <span class="n">oln_pi_1</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">IterativeMultipleTryMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_acceptance_check</span><span class="p">(</span><span class="n">_xi_1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">u</span><span class="p">],</span>
                                                                                                                              <span class="kc">False</span><span class="p">,</span> <span class="n">dc_prior</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;dc_prior&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">oln_pi_1</span><span class="p">:</span>
                        <span class="c1"># If accepted sample, try to get the sacale_factor</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale_factori_1</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                            <span class="n">oscale_factori_1</span> <span class="o">=</span> <span class="n">scale_factori_1</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">oscale_factori_1</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">return</span> <span class="n">oxi_1</span><span class="p">,</span> <span class="n">oln_pi_1</span><span class="p">,</span> <span class="n">oscale_factori_1</span><span class="p">,</span> <span class="n">u</span>
                <span class="c1"># No Accepted samples</span>
                <span class="k">return</span> <span class="p">{},</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">)</span>
            <span class="c1"># No accepted samples</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ln_pi_1</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_events</span><span class="p">)],</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">return</span> <span class="p">{},</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi_1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">IterativeMultipleTryMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_acceptance_check</span><span class="p">(</span><span class="n">xi_1</span><span class="p">,</span> <span class="n">ln_pi_1</span><span class="p">,</span> <span class="n">scale_factori_1</span><span class="p">,</span> <span class="n">dc_prior</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;dc_prior&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_modify_acceptance_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">non_zero_percentage</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjusts the acceptance rate parameters based on the targetted acceptance rate.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IterativeMultipleTryMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_modify_acceptance_rate</span><span class="p">(</span><span class="n">non_zero_percentage</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_number_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">min_acceptance_rate</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_number_samples</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">IterativeMultipleTryTransDMetropolisHastingsGaussianTape</span><span class="p">(</span><span class="n">IterativeTransDMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="n">IterativeMultipleTryMetropolisHastingsGaussianTape</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trans-Dimensional Metropolis-Hastings Markov chain Monte Carlo Algorithm using Gaussian Transition PDF and Tape parameterisation, chain length ends maximum length</span>

<span class="sd">    Trans Dimensional sampling, jumping between double-couple and full moment tensor models.</span>
<span class="sd">    Algorithm ends when the number of samples in the chain equals the chain_length, where the chain length corresponds to the number of accepted samples.</span>
<span class="sd">    The parameterisation is from Tape and Tape (A geometric setting for moment tensors, Tape and Tape, 2012, GJI 190 pp 476-490).</span>

<span class="sd">    This is a child class of both the IterativeTransDMetropolisHastingsGaussianTape and IterativeMultipleTryMetropolisHastingsGaussianTape</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialisation of Trans-Dimensional Metropolis-Hastings Markov chain Monte Carlo Algorithm using Gaussian Transition PDF and Tape parameterisation, chain length ends maximum length</span>


<span class="sd">        This is a child class of both the IterativeTransDMetropolisHastingsGaussianTape and IterativeMultipleTryMetropolisHastingsGaussianTape</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IterativeMultipleTryTransDMetropolisHastingsGaussianTape</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">new_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates new sample</span>

<span class="sd">        Generates a new sample by drawing a new sample from the gaussian transition pdf, conditional on the previous sample.</span>
<span class="sd">        Probability if the sample jumping between models given by the dimension_jump_prob kwarg on initialisation.</span>

<span class="sd">        Returns</span>
<span class="sd">            New sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IterativeMultipleTryMetropolisHastingsGaussianTape</span><span class="o">.</span><span class="n">new_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension_jump_prob</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_jump_params</span><span class="p">)</span>
</pre></div>
</div>
<p>There are also Cython functions:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="c">#!python</span>
<span class="c"># cython: infer_types=True</span>


<span class="c"># **Restricted:  For Non-Commercial Use Only**</span>
<span class="c"># This code is protected intellectual property and is available solely for teaching</span>
<span class="c"># and non-commercially funded academic research purposes.</span>
<span class="c">#</span>
<span class="c"># Applications for commercial use should be made to Schlumberger or the University of Cambridge.</span>

<span class="k">cimport</span> <span class="nn">cython</span>
<span class="k">cimport</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="k">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="k">import</span> <span class="nn">unittest</span>
<span class="k">from</span> <span class="nn">cpython</span> <span class="k">cimport</span> <span class="nb">bool</span>
<span class="k">from</span> <span class="nn">libc.stdlib</span> <span class="k">cimport</span> <span class="n">rand</span><span class="p">,</span> <span class="n">RAND_MAX</span>
<span class="cp">IF</span> <span class="n">UNAME_SYSNAME</span> <span class="o">==</span> <span class="s">&quot;Windows&quot;</span><span class="p">:</span>
    <span class="k">from</span> <span class="nn">libc.math</span> <span class="k">cimport</span> <span class="n">HUGE_VAL</span> <span class="k">as</span> <span class="n">inf</span>
<span class="cp">ELSE</span><span class="p">:</span>
    <span class="k">from</span> <span class="nn">libc.math</span> <span class="k">cimport</span> <span class="n">INFINITY</span> <span class="k">as</span> <span class="n">inf</span>
    <span class="k">from</span> <span class="nn">libc.math</span> <span class="k">cimport</span> <span class="n">fmin</span>
    <span class="k">from</span> <span class="nn">libc.math</span> <span class="k">cimport</span> <span class="n">erf</span>
    <span class="k">from</span> <span class="nn">libc.math</span> <span class="k">cimport</span> <span class="n">tgamma</span>
<span class="k">from</span> <span class="nn">libc.math</span> <span class="k">cimport</span> <span class="n">sqrt</span>
<span class="k">from</span> <span class="nn">libc.math</span> <span class="k">cimport</span> <span class="n">exp</span>
<span class="k">from</span> <span class="nn">libc.math</span> <span class="k">cimport</span> <span class="nb">pow</span>
<span class="k">from</span> <span class="nn">libc.math</span> <span class="k">cimport</span> <span class="n">fabs</span>
<span class="k">from</span> <span class="nn">libc.math</span> <span class="k">cimport</span> <span class="n">fmod</span>
<span class="k">from</span> <span class="nn">libc.math</span> <span class="k">cimport</span> <span class="n">cos</span>
<span class="k">from</span> <span class="nn">libc.math</span> <span class="k">cimport</span> <span class="n">acos</span>
<span class="k">from</span> <span class="nn">libc.math</span> <span class="k">cimport</span> <span class="n">sin</span>
<span class="k">from</span> <span class="nn">libc.math</span> <span class="k">cimport</span> <span class="n">M_PI</span> <span class="k">as</span> <span class="n">pi</span>
<span class="k">from</span> <span class="nn">libc.math</span> <span class="k">cimport</span> <span class="n">M_SQRT2</span> <span class="k">as</span> <span class="n">sqrt2</span>

<span class="k">from</span> <span class="nn">MTfit.convert.cmoment_tensor_conversion</span> <span class="k">cimport</span> <span class="n">cTape_MT6</span>

<span class="k">ctypedef</span> <span class="n">double</span> <span class="n">DTYPE_t</span>
<span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">PI2</span><span class="o">=</span><span class="mf">2</span><span class="o">*</span><span class="n">pi</span>  


<span class="k">ctypedef</span> <span class="n">DTYPE_t</span> <span class="p">(</span><span class="o">*</span><span class="n">jump_params_ptr</span><span class="p">)(</span><span class="n">DTYPE_t</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">)</span>
<span class="k">ctypedef</span> <span class="n">DTYPE_t</span> <span class="p">(</span><span class="o">*</span><span class="n">prior_ratio_ptr</span><span class="p">)(</span><span class="n">DTYPE_t</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">)</span> <span class="k">nogil</span>
<span class="k">ctypedef</span> <span class="n">DTYPE_t</span> <span class="p">(</span><span class="o">*</span><span class="n">transition_ratio_ptr</span><span class="p">)(</span><span class="n">DTYPE_t</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">)</span> <span class="k">nogil</span>

<span class="c">#Windows specific functions - in libc.math otherwise</span>
<span class="cp">IF</span> <span class="n">UNAME_SYSNAME</span> <span class="o">==</span> <span class="s">&quot;Windows&quot;</span><span class="p">:</span>    
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">ND</span><span class="o">=</span><span class="mf">1902.9928503773808</span><span class="o">*</span><span class="mf">1.10452194071529090000</span> <span class="c">#Calculated from python and MATLAB</span>
    
    <span class="c">#Approx for erf function</span>
    <span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
    <span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
    <span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
    <span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">double</span> <span class="nf">erf</span><span class="p">(</span><span class="n">double</span> <span class="n">x</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
        <span class="c"># constants</span>
        <span class="k">cdef</span> <span class="kt">double</span> <span class="nf">a1</span> <span class="o">=</span>  <span class="mf">0.254829592</span>
        <span class="k">cdef</span> <span class="kt">double</span> <span class="nf">a2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.284496736</span>
        <span class="k">cdef</span> <span class="kt">double</span> <span class="nf">a3</span> <span class="o">=</span>  <span class="mf">1.421413741</span>
        <span class="k">cdef</span> <span class="kt">double</span> <span class="nf">a4</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.453152027</span>
        <span class="k">cdef</span> <span class="kt">double</span> <span class="nf">a5</span> <span class="o">=</span>  <span class="mf">1.061405429</span>
        <span class="k">cdef</span> <span class="kt">double</span> <span class="nf">p</span>  <span class="o">=</span>  <span class="mf">0.3275911</span>
        <span class="c"># Save the sign of x</span>
        <span class="k">cdef</span> <span class="kt">int</span> <span class="nf">sign</span> <span class="o">=</span> <span class="mf">1</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mf">0</span><span class="p">:</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">fabs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c"># A&amp;S formula 7.1.26</span>
        <span class="k">cdef</span> <span class="kt">double</span> <span class="nf">t</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">p</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
        <span class="k">cdef</span> <span class="kt">double</span> <span class="nf">y</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(((((</span><span class="n">a5</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">a4</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">a3</span><span class="p">)</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">a2</span><span class="p">)</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">a1</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sign</span><span class="o">*</span><span class="n">y</span>
    
    <span class="c">#no fmin so acceptance different to *nix</span>
    <span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
    <span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
    <span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
    <span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">acceptance</span><span class="p">(</span><span class="n">transition_ratio_ptr</span> <span class="n">transition_ratio_fn</span><span class="p">,</span><span class="n">prior_ratio_ptr</span> <span class="n">prior_ratio_fn</span><span class="p">,</span><span class="n">jump_params_ptr</span> <span class="n">jump_params_fn</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">gamma</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">delta</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">h</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">sigma</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">g0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">g_s</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">d0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">d_s</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">h0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">h_s</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">s0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">s_s</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">ln_p</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">ln_p0</span><span class="p">,</span><span class="nb">int</span> <span class="n">jump</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">qg</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">qd</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">sg</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">sd</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">proposal_normalisation</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">p_dc</span><span class="p">)</span> <span class="p">:</span>
        <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">acc</span>
        <span class="k">if</span> <span class="n">jump</span><span class="o">&gt;</span><span class="mf">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gamma</span><span class="o">==</span><span class="mf">0.0</span> <span class="ow">and</span> <span class="n">delta</span><span class="o">==</span><span class="mf">0.0</span><span class="p">:</span>
                <span class="c">#MT to DC</span>
                <span class="n">model_prior_ratio</span><span class="o">=</span><span class="n">p_dc</span><span class="o">/</span><span class="p">(</span><span class="mf">1</span><span class="o">-</span><span class="n">p_dc</span><span class="p">)</span>
                <span class="n">acc</span><span class="o">=</span><span class="n">exp</span><span class="p">(</span><span class="n">ln_p</span><span class="o">-</span><span class="n">ln_p0</span><span class="p">)</span><span class="o">*</span><span class="n">prior_ratio_fn</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">g0</span><span class="p">,</span><span class="n">d0</span><span class="p">)</span><span class="o">*</span><span class="n">jump_params_fn</span><span class="p">(</span><span class="n">qg</span><span class="p">,</span><span class="n">qd</span><span class="p">,</span><span class="n">sg</span><span class="p">,</span><span class="n">sd</span><span class="p">,</span> <span class="n">proposal_normalisation</span><span class="p">)</span><span class="o">*</span><span class="n">model_prior_ratio</span>
            <span class="k">elif</span> <span class="n">g0</span><span class="o">==</span><span class="mf">0.0</span> <span class="ow">and</span> <span class="n">d0</span><span class="o">==</span><span class="mf">0.0</span> <span class="p">:</span>
                <span class="c">#DC to MT</span>
                <span class="n">model_prior_ratio</span><span class="o">=</span><span class="p">(</span><span class="mf">1</span><span class="o">-</span><span class="n">p_dc</span><span class="p">)</span><span class="o">/</span><span class="n">p_dc</span>
                <span class="n">acc</span><span class="o">=</span><span class="n">exp</span><span class="p">(</span><span class="n">ln_p</span><span class="o">-</span><span class="n">ln_p0</span><span class="p">)</span><span class="o">*</span><span class="n">prior_ratio_fn</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">g0</span><span class="p">,</span><span class="n">d0</span><span class="p">)</span><span class="o">/</span><span class="n">jump_params_fn</span><span class="p">(</span><span class="n">qg</span><span class="p">,</span><span class="n">qd</span><span class="p">,</span><span class="n">sg</span><span class="p">,</span><span class="n">sd</span><span class="p">,</span><span class="n">proposal_normalisation</span><span class="p">)</span><span class="o">*</span><span class="n">model_prior_ratio</span>            
        <span class="k">else</span><span class="p">:</span>   
            <span class="n">acc</span><span class="o">=</span><span class="n">exp</span><span class="p">(</span><span class="n">ln_p</span><span class="o">-</span><span class="n">ln_p0</span><span class="p">)</span><span class="o">*</span><span class="n">transition_ratio_fn</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">g0</span><span class="p">,</span><span class="n">g_s</span><span class="p">,</span><span class="n">d0</span><span class="p">,</span><span class="n">d_s</span><span class="p">,</span><span class="n">h0</span><span class="p">,</span><span class="n">h_s</span><span class="p">,</span><span class="n">s0</span><span class="p">,</span><span class="n">s_s</span><span class="p">)</span><span class="o">*</span><span class="n">prior_ratio_fn</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">g0</span><span class="p">,</span><span class="n">d0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">acc</span><span class="o">&lt;</span><span class="mf">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">acc</span>
        <span class="k">return</span> <span class="mf">1</span>
<span class="cp">ELSE</span><span class="p">:</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">ND</span><span class="o">=</span><span class="n">tgamma</span><span class="p">(</span><span class="mf">11.490</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">tgamma</span><span class="p">(</span><span class="mf">5.745</span><span class="p">)</span><span class="o">*</span><span class="n">tgamma</span><span class="p">(</span><span class="mf">5.745</span><span class="p">))</span><span class="o">*</span><span class="mf">1.10452194071529090000</span>

    <span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
    <span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
    <span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
    <span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">acceptance</span><span class="p">(</span><span class="n">transition_ratio_ptr</span> <span class="n">transition_ratio_fn</span><span class="p">,</span><span class="n">prior_ratio_ptr</span> <span class="n">prior_ratio_fn</span><span class="p">,</span><span class="n">jump_params_ptr</span> <span class="n">jump_params_fn</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">gamma</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">delta</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">h</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">sigma</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">g0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">g_s</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">d0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">d_s</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">h0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">h_s</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">s0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">s_s</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">ln_p</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">ln_p0</span><span class="p">,</span><span class="nb">int</span> <span class="n">jump</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">qg</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">qd</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">sg</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">sd</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">proposal_normalisation</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">p_dc</span><span class="p">)</span> <span class="p">:</span>
        <span class="k">if</span> <span class="n">jump</span><span class="o">&gt;</span><span class="mf">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gamma</span><span class="o">==</span><span class="mf">0.0</span> <span class="ow">and</span> <span class="n">delta</span><span class="o">==</span><span class="mf">0.0</span><span class="p">:</span>
                <span class="n">model_prior_ratio</span><span class="o">=</span><span class="n">p_dc</span><span class="o">/</span><span class="p">(</span><span class="mf">1</span><span class="o">-</span><span class="n">p_dc</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">fmin</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="n">exp</span><span class="p">(</span><span class="n">ln_p</span><span class="o">-</span><span class="n">ln_p0</span><span class="p">)</span><span class="o">*</span><span class="n">prior_ratio_fn</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">g0</span><span class="p">,</span><span class="n">d0</span><span class="p">)</span><span class="o">*</span><span class="n">jump_params_fn</span><span class="p">(</span><span class="n">qg</span><span class="p">,</span><span class="n">qd</span><span class="p">,</span><span class="n">sg</span><span class="p">,</span><span class="n">sd</span><span class="p">,</span> <span class="n">proposal_normalisation</span><span class="p">)</span><span class="o">*</span><span class="n">model_prior_ratio</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">g0</span><span class="o">==</span><span class="mf">0.0</span> <span class="ow">and</span> <span class="n">d0</span><span class="o">==</span><span class="mf">0.0</span> <span class="p">:</span>
                <span class="n">model_prior_ratio</span><span class="o">=</span><span class="p">(</span><span class="mf">1</span><span class="o">-</span><span class="n">p_dc</span><span class="p">)</span><span class="o">/</span><span class="n">p_dc</span>
                <span class="k">return</span> <span class="n">fmin</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="n">exp</span><span class="p">(</span><span class="n">ln_p</span><span class="o">-</span><span class="n">ln_p0</span><span class="p">)</span><span class="o">*</span><span class="n">prior_ratio_fn</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">g0</span><span class="p">,</span><span class="n">d0</span><span class="p">)</span><span class="o">/</span><span class="n">jump_params_fn</span><span class="p">(</span><span class="n">qg</span><span class="p">,</span><span class="n">qd</span><span class="p">,</span><span class="n">sg</span><span class="p">,</span><span class="n">sd</span><span class="p">,</span><span class="n">proposal_normalisation</span><span class="p">)</span><span class="o">*</span><span class="n">model_prior_ratio</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fmin</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="n">exp</span><span class="p">(</span><span class="n">ln_p</span><span class="o">-</span><span class="n">ln_p0</span><span class="p">)</span><span class="o">*</span><span class="n">transition_ratio_fn</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">g0</span><span class="p">,</span><span class="n">g_s</span><span class="p">,</span><span class="n">d0</span><span class="p">,</span><span class="n">d_s</span><span class="p">,</span><span class="n">h0</span><span class="p">,</span><span class="n">h_s</span><span class="p">,</span><span class="n">s0</span><span class="p">,</span><span class="n">s_s</span><span class="p">)</span><span class="o">*</span><span class="n">prior_ratio_fn</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">g0</span><span class="p">,</span><span class="n">d0</span><span class="p">))</span>

<span class="c">#Gaussian PDF</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">DTYPE_t</span> <span class="nf">gaussian_pdf</span><span class="p">(</span><span class="n">DTYPE_t</span> <span class="n">x</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">mu</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">s</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="mf">1</span><span class="o">/</span><span class="p">(</span><span class="n">sqrt2</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">s</span><span class="p">))</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">s</span><span class="p">))</span>

<span class="c">#Gaussian CDF</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">DTYPE_t</span> <span class="nf">gaussian_cdf</span><span class="p">(</span><span class="n">DTYPE_t</span> <span class="n">x</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">mu</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">s</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mf">1</span><span class="o">+</span><span class="n">erf</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">s</span><span class="o">*</span><span class="n">sqrt2</span><span class="p">)))</span>

<span class="c">#Inline functions for Gaussian transition ratios - normalising for truncated gaussian PDFs</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">DTYPE_t</span> <span class="nf">gaussian_transition_mt</span><span class="p">(</span><span class="n">DTYPE_t</span> <span class="n">gamma</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">delta</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">h</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">sigma</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">g0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">g_s</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">d0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">d_s</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">h0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">h_s</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">s0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">s_s</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="n">N</span><span class="o">=</span><span class="p">(</span><span class="n">gaussian_cdf</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mf">6</span><span class="p">,</span><span class="n">g0</span><span class="p">,</span><span class="n">g_s</span><span class="p">)</span><span class="o">-</span><span class="n">gaussian_cdf</span><span class="p">(</span><span class="o">-</span><span class="n">pi</span><span class="o">/</span><span class="mf">6</span><span class="p">,</span><span class="n">g0</span><span class="p">,</span><span class="n">g_s</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">gaussian_cdf</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mf">2</span><span class="p">,</span><span class="n">d0</span><span class="p">,</span><span class="n">d_s</span><span class="p">)</span><span class="o">-</span><span class="n">gaussian_cdf</span><span class="p">(</span><span class="o">-</span><span class="n">pi</span><span class="o">/</span><span class="mf">2</span><span class="p">,</span><span class="n">d0</span><span class="p">,</span><span class="n">d_s</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">gaussian_transition_dc</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">h0</span><span class="p">,</span><span class="n">h_s</span><span class="p">,</span><span class="n">s0</span><span class="p">,</span><span class="n">s_s</span><span class="p">)</span><span class="o">/</span><span class="n">N</span>

<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">DTYPE_t</span> <span class="nf">gaussian_transition_dc</span><span class="p">(</span><span class="n">DTYPE_t</span> <span class="n">h</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">sigma</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">h0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">h_s</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">s0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">s_s</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="n">N</span><span class="o">=</span><span class="p">(</span><span class="n">gaussian_cdf</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="n">h0</span><span class="p">,</span><span class="n">h_s</span><span class="p">)</span><span class="o">-</span><span class="n">gaussian_cdf</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="n">h0</span><span class="p">,</span><span class="n">h_s</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">gaussian_cdf</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mf">2</span><span class="p">,</span><span class="n">s0</span><span class="p">,</span><span class="n">s_s</span><span class="p">)</span><span class="o">-</span><span class="n">gaussian_cdf</span><span class="p">(</span><span class="o">-</span><span class="n">pi</span><span class="o">/</span><span class="mf">2</span><span class="p">,</span><span class="n">s0</span><span class="p">,</span><span class="n">s_s</span><span class="p">))</span>
    <span class="k">return</span> <span class="mf">1</span><span class="o">/</span><span class="n">N</span>

<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">DTYPE_t</span> <span class="nf">gaussian_transition_ratio</span><span class="p">(</span><span class="n">DTYPE_t</span> <span class="n">gamma</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">delta</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">h</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">sigma</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">g0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">g_s</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">d0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">d_s</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">h0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">h_s</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">s0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">s_s</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">gamma</span><span class="o">==</span><span class="mf">0.0</span> <span class="ow">and</span> <span class="n">delta</span><span class="o">==</span><span class="mf">0.0</span> <span class="ow">and</span> <span class="n">g0</span><span class="o">==</span><span class="mf">0.0</span> <span class="ow">and</span> <span class="n">d0</span><span class="o">==</span><span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gaussian_transition_dc</span><span class="p">(</span><span class="n">h0</span><span class="p">,</span><span class="n">s0</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">h_s</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">s_s</span><span class="p">)</span><span class="o">/</span><span class="n">gaussian_transition_dc</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">h0</span><span class="p">,</span><span class="n">h_s</span><span class="p">,</span><span class="n">s0</span><span class="p">,</span><span class="n">s_s</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gaussian_transition_mt</span><span class="p">(</span><span class="n">g0</span><span class="p">,</span><span class="n">d0</span><span class="p">,</span><span class="n">h0</span><span class="p">,</span><span class="n">s0</span><span class="p">,</span><span class="n">gamma</span><span class="p">,</span><span class="n">g_s</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">d_s</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">h_s</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">s_s</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">gaussian_transition_mt</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">g0</span><span class="p">,</span><span class="n">g_s</span><span class="p">,</span><span class="n">d0</span><span class="p">,</span><span class="n">d_s</span><span class="p">,</span><span class="n">h0</span><span class="p">,</span><span class="n">h_s</span><span class="p">,</span><span class="n">s0</span><span class="p">,</span><span class="n">s_s</span><span class="p">))</span>

<span class="c">#Prior distributions - distribution for delta from numerical tests.</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">DTYPE_t</span> <span class="nf">uniform_delta_dist</span><span class="p">(</span><span class="n">DTYPE_t</span> <span class="n">delta</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="c">#based on beta dist</span>
    <span class="n">b</span><span class="o">=</span><span class="mf">5.745</span>
    <span class="n">d</span><span class="o">=</span><span class="p">(</span><span class="n">delta</span><span class="o">+</span><span class="n">pi</span><span class="o">/</span><span class="mf">2</span><span class="p">)</span><span class="o">/</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">ND</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="mf">1</span><span class="o">-</span><span class="n">d</span><span class="p">),</span><span class="n">b</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span><span class="o">/</span><span class="n">pi</span>

<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="c">#Prior ratios, including DC/MT jumps for relative inversion</span>
<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">DTYPE_t</span> <span class="nf">uniform_prior_ratio</span><span class="p">(</span><span class="n">DTYPE_t</span> <span class="n">gamma</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">delta</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">g0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">d0</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">gamma</span><span class="o">==</span><span class="mf">0.0</span> <span class="ow">and</span> <span class="n">delta</span><span class="o">==</span><span class="mf">0.0</span> <span class="ow">and</span> <span class="n">g0</span><span class="o">==</span><span class="mf">0.0</span> <span class="ow">and</span> <span class="n">d0</span><span class="o">==</span><span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1.0</span>
    <span class="k">elif</span> <span class="n">gamma</span><span class="o">==</span><span class="mf">0.0</span> <span class="ow">and</span> <span class="n">delta</span><span class="o">==</span><span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1</span><span class="o">/</span><span class="p">(</span><span class="mf">1.5</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="mf">3</span><span class="o">*</span><span class="n">g0</span><span class="p">)</span><span class="o">*</span><span class="n">uniform_delta_dist</span><span class="p">(</span><span class="n">d0</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">g0</span><span class="o">==</span><span class="mf">0.0</span> <span class="ow">and</span> <span class="n">d0</span><span class="o">==</span><span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1.5</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="mf">3</span><span class="o">*</span><span class="n">gamma</span><span class="p">)</span><span class="o">*</span><span class="n">uniform_delta_dist</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cos</span><span class="p">(</span><span class="mf">3</span><span class="o">*</span><span class="n">gamma</span><span class="p">)</span><span class="o">*</span><span class="n">uniform_delta_dist</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="mf">3</span><span class="o">*</span><span class="n">g0</span><span class="p">)</span><span class="o">*</span><span class="n">uniform_delta_dist</span><span class="p">(</span><span class="n">d0</span><span class="p">))</span>

<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">DTYPE_t</span> <span class="nf">flat_prior_ratio</span><span class="p">(</span><span class="n">DTYPE_t</span> <span class="n">gamma</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">delta</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">g0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">d0</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="k">return</span> <span class="mf">1.0</span>

<span class="c"># Functions for obtaining new Tape parameter samples etc.</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">new_gamma</span><span class="p">(</span><span class="n">DTYPE_t</span> <span class="n">g0</span><span class="p">,</span> <span class="n">DTYPE_t</span> <span class="n">g_s</span><span class="p">):</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">gamma</span>
    <span class="n">gamma</span><span class="o">=</span><span class="n">g_s</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="o">+</span><span class="n">g0</span>
    <span class="k">while</span> <span class="n">fabs</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span><span class="o">&gt;</span><span class="n">pi</span><span class="o">/</span><span class="mf">6</span><span class="p">:</span>
        <span class="n">gamma</span><span class="o">=</span><span class="n">g_s</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="o">+</span><span class="n">g0</span>
    <span class="k">return</span> <span class="n">gamma</span>

<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">new_delta</span><span class="p">(</span><span class="n">DTYPE_t</span> <span class="n">d0</span><span class="p">,</span> <span class="n">DTYPE_t</span> <span class="n">d_s</span><span class="p">):</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">delta</span>
    <span class="n">delta</span><span class="o">=</span><span class="n">d_s</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="o">+</span><span class="n">d0</span>
    <span class="k">while</span> <span class="n">fabs</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span><span class="o">&gt;</span><span class="n">pi</span><span class="o">/</span><span class="mf">2</span><span class="p">:</span>
        <span class="n">delta</span><span class="o">=</span><span class="n">d_s</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="o">+</span><span class="n">d0</span>
    <span class="k">return</span> <span class="n">delta</span>

<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">new_kappa</span><span class="p">(</span><span class="n">DTYPE_t</span> <span class="n">k0</span><span class="p">,</span> <span class="n">DTYPE_t</span> <span class="n">k_s</span><span class="p">):</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">kn</span><span class="o">=</span><span class="n">k_s</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="o">+</span><span class="n">k0</span>
    <span class="k">if</span> <span class="n">fabs</span><span class="p">(</span><span class="n">kn</span><span class="p">)</span><span class="o">&lt;</span><span class="n">PI2</span><span class="p">:</span>
        <span class="n">kn</span><span class="o">=</span><span class="n">fmod</span><span class="p">(</span><span class="n">kn</span><span class="p">,</span><span class="n">PI2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kn</span><span class="o">&lt;</span><span class="mf">0.0</span><span class="p">:</span>
        <span class="n">kn</span><span class="o">+=</span><span class="n">PI2</span>
    <span class="k">return</span> <span class="n">kn</span>

<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">new_h</span><span class="p">(</span><span class="n">DTYPE_t</span> <span class="n">h0</span><span class="p">,</span> <span class="n">DTYPE_t</span> <span class="n">h_s</span><span class="p">):</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">h</span>
    <span class="n">h</span><span class="o">=</span><span class="n">h_s</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="o">+</span><span class="n">h0</span>
    <span class="k">while</span> <span class="n">h</span><span class="o">&gt;</span><span class="mf">1</span> <span class="ow">or</span> <span class="n">h</span><span class="o">&lt;</span><span class="mf">0</span><span class="p">:</span>
        <span class="n">h</span><span class="o">=</span><span class="n">h_s</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="o">+</span><span class="n">h0</span>
    <span class="k">return</span> <span class="n">h</span>

<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">new_sigma</span><span class="p">(</span><span class="n">DTYPE_t</span> <span class="n">s0</span><span class="p">,</span> <span class="n">DTYPE_t</span> <span class="n">s_s</span><span class="p">):</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">sigma</span>
    <span class="n">sigma</span><span class="o">=</span><span class="n">s_s</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="o">+</span><span class="n">s0</span>
    <span class="k">while</span> <span class="n">fabs</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span><span class="o">&gt;</span><span class="n">pi</span><span class="o">/</span><span class="mf">2</span><span class="p">:</span>
        <span class="n">sigma</span><span class="o">=</span><span class="n">s_s</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="o">+</span><span class="n">s0</span>
    <span class="k">return</span> <span class="n">sigma</span>

<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">convert_sample</span><span class="p">(</span><span class="n">DTYPE_t</span> <span class="n">gamma</span><span class="p">,</span><span class="n">DTYPE_t</span>  <span class="n">delta</span><span class="p">,</span><span class="n">DTYPE_t</span>  <span class="n">kappa</span><span class="p">,</span><span class="n">DTYPE_t</span>  <span class="n">h</span><span class="p">,</span><span class="n">DTYPE_t</span>  <span class="n">sigma</span><span class="p">):</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span>[<span class="p">:,::</span><span class="mf">1</span><span class="p">]</span> <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mf">6</span><span class="p">,</span><span class="mf">1</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span>[<span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mf">6</span><span class="p">))</span>
    <span class="n">cTape_MT6</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">[</span><span class="mf">0</span><span class="p">],</span><span class="n">gamma</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">sigma</span><span class="p">)</span>
    <span class="n">M</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
    <span class="n">M</span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span>
    <span class="n">M</span><span class="p">[</span><span class="mf">2</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="mf">2</span><span class="p">]</span>
    <span class="n">M</span><span class="p">[</span><span class="mf">3</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="mf">3</span><span class="p">]</span>
    <span class="n">M</span><span class="p">[</span><span class="mf">4</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="mf">4</span><span class="p">]</span>
    <span class="n">M</span><span class="p">[</span><span class="mf">5</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="mf">5</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">DTYPE_t</span> <span class="nf">ranf</span><span class="p">()</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">rand</span><span class="p">()</span><span class="o">/&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">RAND_MAX</span>

<span class="c">#Acceptance check functions single and multiple events</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="k">cdef</span> <span class="kt">int</span> <span class="nf">c_acceptance_check</span><span class="p">(</span><span class="n">transition_ratio_ptr</span> <span class="n">transition_ratio_fn</span><span class="p">,</span><span class="n">prior_ratio_ptr</span> <span class="n">prior_ratio_fn</span><span class="p">,</span><span class="n">jump_params_ptr</span> <span class="n">jump_params_fn</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">gamma</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span>  <span class="n">delta</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span>  <span class="n">h</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span>  <span class="n">sigma</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">kappa</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">g0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">g_s</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">d0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">d_s</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">h0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">h_s</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">s0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">s_s</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">ln_p</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">ln_p0</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">k0</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">qg</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">qd</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">sg</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">sd</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">proposal_normalisation</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">p_dc</span><span class="p">):</span>
    <span class="k">cdef</span> <span class="kt">Py_ssize_t</span> <span class="nf">umax</span><span class="o">=</span><span class="n">ln_p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
    <span class="k">cdef</span> <span class="kt">Py_ssize_t</span> <span class="nf">u</span>
    <span class="k">cdef</span> <span class="kt">int</span> <span class="nf">jump</span><span class="o">=</span><span class="mf">0</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">acc</span><span class="o">=</span><span class="mf">0</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">umax</span><span class="p">):</span>
        <span class="n">jump</span><span class="o">=</span><span class="mf">0</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">g0</span><span class="o">==</span><span class="mf">0.0</span> <span class="ow">and</span> <span class="n">d0</span><span class="o">==</span><span class="mf">0.0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">gamma</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">==</span><span class="mf">0.0</span> <span class="ow">and</span> <span class="n">delta</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">==</span><span class="mf">0.0</span><span class="p">))</span> <span class="ow">and</span>  <span class="ow">not</span> <span class="n">gamma</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">==</span><span class="n">g0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">delta</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">==</span><span class="n">d0</span> <span class="ow">and</span> <span class="n">h0</span><span class="o">==</span><span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="ow">and</span> <span class="n">s0</span><span class="o">==</span><span class="n">sigma</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="ow">and</span> <span class="n">k0</span><span class="o">==</span><span class="n">kappa</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">jump</span><span class="o">=</span><span class="mf">1</span>
        <span class="k">if</span> <span class="n">ln_p</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">==-</span><span class="n">inf</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">acceptance</span><span class="p">(</span><span class="n">transition_ratio_fn</span><span class="p">,</span><span class="n">prior_ratio_fn</span><span class="p">,</span><span class="n">jump_params_fn</span><span class="p">,</span><span class="n">gamma</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">delta</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">g0</span><span class="p">,</span> <span class="n">g_s</span><span class="p">,</span> <span class="n">d0</span><span class="p">,</span> <span class="n">d_s</span><span class="p">,</span> <span class="n">h0</span><span class="p">,</span> <span class="n">h_s</span><span class="p">,</span> <span class="n">s0</span><span class="p">,</span> <span class="n">s_s</span><span class="p">,</span> <span class="n">ln_p</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">ln_p0</span><span class="p">,</span><span class="n">jump</span><span class="p">,</span><span class="n">qg</span><span class="p">[</span><span class="n">u</span><span class="p">],</span><span class="n">qd</span><span class="p">[</span><span class="n">u</span><span class="p">],</span><span class="n">sg</span><span class="p">,</span><span class="n">sd</span><span class="p">,</span><span class="n">proposal_normalisation</span><span class="p">,</span><span class="n">p_dc</span><span class="p">)</span><span class="o">&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span><span class="n">u</span>
    <span class="k">return</span> <span class="o">-</span><span class="mf">1</span>

<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="k">cdef</span> <span class="kt">int</span> <span class="nf">c_me_acceptance_check</span><span class="p">(</span><span class="n">transition_ratio_ptr</span> <span class="n">transition_ratio_fn</span><span class="p">,</span><span class="n">prior_ratio_ptr</span> <span class="n">prior_ratio_fn</span><span class="p">,</span><span class="n">jump_params_ptr</span> <span class="n">jump_params_fn</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[:,::</span><span class="mf">1</span><span class="p">]</span> <span class="n">gamma</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[:,::</span><span class="mf">1</span><span class="p">]</span>  <span class="n">delta</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[:,::</span><span class="mf">1</span><span class="p">]</span>  <span class="n">h</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[:,::</span><span class="mf">1</span><span class="p">]</span>  <span class="n">sigma</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[:,::</span><span class="mf">1</span><span class="p">]</span> <span class="n">kappa</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">g0</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">g_s</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">d0</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">d_s</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">h0</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">h_s</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">s0</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">s_s</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">ln_p</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">ln_p0</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">k0</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[:,::</span><span class="mf">1</span><span class="p">]</span> <span class="n">qg</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[:,::</span><span class="mf">1</span><span class="p">]</span> <span class="n">qd</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">sg</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">sd</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">proposal_normalisation</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">p_dc</span><span class="p">):</span>
    <span class="k">cdef</span> <span class="kt">Py_ssize_t</span> <span class="nf">umax</span><span class="o">=</span><span class="n">ln_p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
    <span class="k">cdef</span> <span class="kt">Py_ssize_t</span> <span class="nf">u</span>
    <span class="k">cdef</span> <span class="kt">Py_ssize_t</span> <span class="nf">nevents</span><span class="o">=</span><span class="n">gamma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span>
    <span class="k">cdef</span> <span class="kt">Py_ssize_t</span> <span class="nf">v</span>
    <span class="k">cdef</span> <span class="kt">int</span> <span class="nf">jump</span><span class="o">=</span><span class="mf">0</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">acc</span><span class="o">=</span><span class="mf">1</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">umax</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ln_p</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">==-</span><span class="n">inf</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nevents</span><span class="p">):</span>
            <span class="n">jump</span><span class="o">=</span><span class="mf">0</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">g0</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">==</span><span class="mf">0.0</span> <span class="ow">and</span> <span class="n">d0</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">==</span><span class="mf">0.0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">gamma</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span><span class="o">==</span><span class="mf">0.0</span> <span class="ow">and</span> <span class="n">delta</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span><span class="o">==</span><span class="mf">0.0</span><span class="p">))</span> <span class="ow">and</span>  <span class="ow">not</span> <span class="n">gamma</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span><span class="o">==</span><span class="n">g0</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">delta</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span><span class="o">==</span><span class="n">d0</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="ow">and</span> <span class="n">h0</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">==</span><span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span> <span class="ow">and</span> <span class="n">s0</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">==</span><span class="n">sigma</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span> <span class="ow">and</span> <span class="n">k0</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">==</span><span class="n">kappa</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]:</span><span class="c">#Check for jump</span>
                <span class="n">jump</span><span class="o">=</span><span class="mf">1</span>
            <span class="n">acc</span><span class="o">*=</span><span class="n">acceptance</span><span class="p">(</span><span class="n">transition_ratio_fn</span><span class="p">,</span><span class="n">prior_ratio_fn</span><span class="p">,</span><span class="n">jump_params_fn</span><span class="p">,</span><span class="n">gamma</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">],</span> <span class="n">delta</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">],</span> <span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">],</span> <span class="n">g0</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">g_s</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">d0</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">d_s</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">h0</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">h_s</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">s0</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">s_s</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="n">jump</span><span class="p">,</span><span class="n">qg</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">],</span><span class="n">qd</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">],</span><span class="n">sg</span><span class="p">[</span><span class="n">v</span><span class="p">],</span><span class="n">sd</span><span class="p">[</span><span class="n">v</span><span class="p">],</span><span class="n">proposal_normalisation</span><span class="p">[</span><span class="n">v</span><span class="p">],</span><span class="n">p_dc</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">acc</span><span class="o">==</span><span class="mf">0</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">v</span><span class="o">&lt;</span><span class="n">nevents</span><span class="o">-</span><span class="mf">1</span> <span class="ow">or</span> <span class="n">acc</span><span class="o">==</span><span class="mf">0.0</span><span class="p">:</span><span class="c">#No acceptance, so no point in continuing</span>
            <span class="k">continue</span>
        <span class="n">acc</span><span class="o">*=</span><span class="n">exp</span><span class="p">(</span><span class="n">ln_p</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">-</span><span class="n">ln_p0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">acc</span><span class="o">&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span><span class="n">u</span>
    <span class="k">return</span> <span class="o">-</span><span class="mf">1</span>

<span class="c">#RJ Jump paramters</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">tuple</span> <span class="nf">flat_jump_params</span><span class="p">(</span><span class="n">DTYPE_t</span> <span class="n">a</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">b</span><span class="p">,):</span>
    <span class="k">return</span>  <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mf">2</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mf">6</span><span class="p">,</span><span class="n">acos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mf">2</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span><span class="o">-</span><span class="n">pi</span><span class="o">/</span><span class="mf">2</span>

<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">tuple</span> <span class="nf">gaussian_jump_params</span><span class="p">(</span><span class="n">DTYPE_t</span> <span class="n">sg</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">sd</span><span class="p">):</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">qg</span><span class="o">=-</span><span class="n">pi</span><span class="o">/</span><span class="mf">2</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">qd</span><span class="o">=-</span><span class="n">pi</span>
    <span class="k">while</span> <span class="n">fabs</span><span class="p">(</span><span class="n">qg</span><span class="p">)</span><span class="o">&gt;</span><span class="n">pi</span><span class="o">/</span><span class="mf">6</span><span class="p">:</span>
        <span class="n">qg</span><span class="o">=</span><span class="n">sg</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">()</span>
    <span class="k">while</span> <span class="n">fabs</span><span class="p">(</span><span class="n">qd</span><span class="p">)</span><span class="o">&gt;</span><span class="n">pi</span><span class="o">/</span><span class="mf">2</span><span class="p">:</span>
        <span class="n">qd</span><span class="o">=</span><span class="n">sd</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">()</span>
    <span class="k">return</span>  <span class="p">(</span><span class="n">qg</span><span class="p">,</span><span class="n">qd</span><span class="p">)</span>

<span class="c">#RJ jump parameter priors</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">DTYPE_t</span> <span class="nf">flat_jump_prob</span><span class="p">(</span><span class="n">DTYPE_t</span> <span class="n">a</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">b</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">sg</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">sd</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">proposal_normalisation</span><span class="p">):</span>
    <span class="c">#N.B. ILLOGICAL - DO NOT USE - WILL ALWAYS ACCEPT JUMP FROM DC to MT (gamma=0 delta=0), i.e. increasing complexity</span>
    <span class="k">return</span>  <span class="mf">3</span><span class="o">/</span><span class="p">(</span><span class="n">PI2</span><span class="p">)</span>

<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">cdivision</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">DTYPE_t</span> <span class="nf">gaussian_jump_prob</span><span class="p">(</span><span class="n">DTYPE_t</span> <span class="n">qg</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">qd</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">sg</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">sd</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">proposal_normalisation</span><span class="p">):</span>
    <span class="k">return</span>  <span class="n">gaussian_pdf</span><span class="p">(</span><span class="n">qg</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="n">sg</span><span class="p">)</span><span class="o">*</span><span class="n">gaussian_pdf</span><span class="p">(</span><span class="n">qd</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="n">sd</span><span class="p">)</span><span class="o">/</span><span class="n">proposal_normalisation</span>

<span class="c">#Python accessible functions for acceptance checks</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">acceptance_check</span><span class="p">(</span><span class="nb">list</span> <span class="n">x</span><span class="p">,</span><span class="nb">dict</span> <span class="n">x0</span><span class="p">,</span><span class="nb">dict</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">ln_p</span><span class="p">,</span> <span class="n">DTYPE_t</span> <span class="n">ln_p0</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">uniform_prior</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">gaussian_jump</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">DTYPE_t</span> <span class="n">dc_prior</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="k">cdef</span> <span class="kt">Py_ssize_t</span> <span class="nf">umax</span><span class="o">=</span><span class="n">ln_p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
    <span class="k">cdef</span> <span class="kt">Py_ssize_t</span> <span class="nf">u</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span>[<span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">gamma</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">umax</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span>[<span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">delta</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">umax</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span>[<span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">h</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">umax</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span>[<span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">sigma</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">umax</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span>[<span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">kappa</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">umax</span><span class="p">))</span>   
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span>[<span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">qg</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">umax</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span>[<span class="p">::</span><span class="mf">1</span><span class="p">]</span> <span class="n">qd</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">umax</span><span class="p">))</span>          
    <span class="k">cdef</span> <span class="kt">transition_ratio_ptr</span> <span class="nf">transition_ratio_fn</span><span class="o">=&amp;</span><span class="n">gaussian_transition_ratio</span>
    <span class="k">cdef</span> <span class="kt">prior_ratio_ptr</span> <span class="nf">prior_ratio_fn</span>    
    <span class="k">cdef</span> <span class="kt">jump_params_ptr</span> <span class="nf">jump_params_fn</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">g0</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">x0</span><span class="p">[</span><span class="s">&#39;gamma&#39;</span><span class="p">]</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">g_s</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">alpha</span><span class="p">[</span><span class="s">&#39;gamma&#39;</span><span class="p">]</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">d0</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">x0</span><span class="p">[</span><span class="s">&#39;delta&#39;</span><span class="p">]</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">d_s</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">alpha</span><span class="p">[</span><span class="s">&#39;delta&#39;</span><span class="p">]</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">h0</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">x0</span><span class="p">[</span><span class="s">&#39;h&#39;</span><span class="p">]</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">h_s</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">alpha</span><span class="p">[</span><span class="s">&#39;h&#39;</span><span class="p">]</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">s0</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">x0</span><span class="p">[</span><span class="s">&#39;sigma&#39;</span><span class="p">]</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">s_s</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">alpha</span><span class="p">[</span><span class="s">&#39;sigma&#39;</span><span class="p">]</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">k0</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">x0</span><span class="p">[</span><span class="s">&#39;kappa&#39;</span><span class="p">]</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">proposal_normalisation</span><span class="o">=</span><span class="mf">1.0</span>
    <span class="k">if</span> <span class="s">&#39;proposal_normalisation&#39;</span> <span class="ow">in</span> <span class="n">alpha</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">proposal_normalisation</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">alpha</span><span class="p">[</span><span class="s">&#39;proposal_normalisation&#39;</span><span class="p">]</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">sg</span><span class="o">=</span><span class="mf">0.1</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">sd</span><span class="o">=</span><span class="mf">0.1</span>
    <span class="k">cdef</span> <span class="kt">int</span> <span class="nf">index</span>
    <span class="k">if</span> <span class="n">gaussian_jump</span><span class="p">:</span>
        <span class="n">jump_params_fn</span><span class="o">=&amp;</span><span class="n">gaussian_jump_prob</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">jump_params_fn</span><span class="o">=&amp;</span><span class="n">flat_jump_prob</span>
    <span class="k">if</span> <span class="n">uniform_prior</span><span class="p">:</span>
        <span class="n">prior_ratio_fn</span><span class="o">=&amp;</span><span class="n">uniform_prior_ratio</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">prior_ratio_fn</span><span class="o">=&amp;</span><span class="n">flat_prior_ratio</span>
    <span class="k">if</span> <span class="s">&#39;gamma_dc&#39;</span> <span class="ow">in</span> <span class="n">alpha</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">sg</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">alpha</span><span class="p">[</span><span class="s">&#39;gamma_dc&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="s">&#39;delta_dc&#39;</span> <span class="ow">in</span> <span class="n">alpha</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">sd</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">alpha</span><span class="p">[</span><span class="s">&#39;delta_dc&#39;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">umax</span><span class="p">):</span>
        <span class="n">gamma</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s">&#39;gamma&#39;</span><span class="p">]</span>
        <span class="n">delta</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s">&#39;delta&#39;</span><span class="p">]</span>
        <span class="n">kappa</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s">&#39;kappa&#39;</span><span class="p">]</span>
        <span class="n">sigma</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s">&#39;sigma&#39;</span><span class="p">]</span>
        <span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s">&#39;h&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s">&#39;g0&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">qg</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s">&#39;g0&#39;</span><span class="p">]</span><span class="c">#g0 from mt sample ==&gt; dc sample</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qg</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s">&#39;gamma&#39;</span><span class="p">];</span><span class="c">#no g0  ==&gt;  mt sample</span>
        <span class="k">if</span> <span class="s">&#39;d0&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">qd</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s">&#39;d0&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qd</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s">&#39;delta&#39;</span><span class="p">];</span>
    <span class="n">index</span><span class="o">=</span><span class="n">c_acceptance_check</span><span class="p">(</span><span class="n">transition_ratio_fn</span><span class="p">,</span><span class="n">prior_ratio_fn</span><span class="p">,</span><span class="n">jump_params_fn</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span> <span class="n">g0</span><span class="p">,</span> <span class="n">g_s</span><span class="p">,</span> <span class="n">d0</span><span class="p">,</span> <span class="n">d_s</span><span class="p">,</span> <span class="n">h0</span><span class="p">,</span> <span class="n">h_s</span><span class="p">,</span> <span class="n">s0</span><span class="p">,</span> <span class="n">s_s</span><span class="p">,</span><span class="n">ln_p</span><span class="p">,</span><span class="n">ln_p0</span><span class="p">,</span><span class="n">k0</span><span class="p">,</span><span class="n">qg</span><span class="p">,</span><span class="n">qd</span><span class="p">,</span><span class="n">sg</span><span class="p">,</span><span class="n">sd</span><span class="p">,</span><span class="n">proposal_normalisation</span><span class="p">,</span><span class="n">dc_prior</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">index</span><span class="o">&gt;=</span><span class="mf">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="n">ln_p</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="n">index</span>
    <span class="k">return</span> <span class="p">{},</span><span class="bp">False</span><span class="p">,</span><span class="n">umax</span>

<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">me_acceptance_check</span><span class="p">(</span><span class="nb">list</span> <span class="n">x</span><span class="p">,</span><span class="nb">list</span> <span class="n">x0</span><span class="p">,</span><span class="nb">list</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">ln_p</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">ln_p0</span><span class="p">,</span><span class="nb">bool</span> <span class="n">uniform_prior</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="nb">bool</span> <span class="n">gaussian_jump</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">DTYPE_t</span><span class="p">[::</span><span class="mf">1</span><span class="p">]</span> <span class="n">dc_prior</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">])):</span>
    <span class="k">cdef</span> <span class="kt">Py_ssize_t</span> <span class="nf">umax</span><span class="o">=</span><span class="n">ln_p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
    <span class="k">cdef</span> <span class="kt">Py_ssize_t</span> <span class="nf">nevents</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
    <span class="k">cdef</span> <span class="kt">Py_ssize_t</span> <span class="nf">u</span>
    <span class="k">cdef</span> <span class="kt">Py_ssize_t</span> <span class="nf">v</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span>[<span class="p">:,::</span><span class="mf">1</span><span class="p">]</span> <span class="n">gamma</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">umax</span><span class="p">,</span><span class="n">nevents</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span>[<span class="p">:,::</span><span class="mf">1</span><span class="p">]</span> <span class="n">delta</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">umax</span><span class="p">,</span><span class="n">nevents</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span>[<span class="p">:,::</span><span class="mf">1</span><span class="p">]</span> <span class="n">h</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">umax</span><span class="p">,</span><span class="n">nevents</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span>[<span class="p">:,::</span><span class="mf">1</span><span class="p">]</span> <span class="n">sigma</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">umax</span><span class="p">,</span><span class="n">nevents</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span>[<span class="p">:,::</span><span class="mf">1</span><span class="p">]</span> <span class="n">kappa</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">umax</span><span class="p">,</span><span class="n">nevents</span><span class="p">))</span>   
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span>[<span class="p">:,::</span><span class="mf">1</span><span class="p">]</span> <span class="n">qg</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">umax</span><span class="p">,</span><span class="n">nevents</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span>[<span class="p">:,::</span><span class="mf">1</span><span class="p">]</span> <span class="n">qd</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">umax</span><span class="p">,</span><span class="n">nevents</span><span class="p">))</span>          
    <span class="k">cdef</span> <span class="kt">transition_ratio_ptr</span> <span class="nf">transition_ratio_fn</span><span class="o">=&amp;</span><span class="n">gaussian_transition_ratio</span>
    <span class="k">cdef</span> <span class="kt">prior_ratio_ptr</span> <span class="nf">prior_ratio_fn</span>    
    <span class="k">cdef</span> <span class="kt">jump_params_ptr</span> <span class="nf">jump_params_fn</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> [<span class="p">::</span><span class="mf">1</span><span class="p">]</span><span class="n">g0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nevents</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> [<span class="p">::</span><span class="mf">1</span><span class="p">]</span><span class="n">g_s</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nevents</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> [<span class="p">::</span><span class="mf">1</span><span class="p">]</span><span class="n">d0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nevents</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> [<span class="p">::</span><span class="mf">1</span><span class="p">]</span><span class="n">d_s</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nevents</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> [<span class="p">::</span><span class="mf">1</span><span class="p">]</span><span class="n">h0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nevents</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> [<span class="p">::</span><span class="mf">1</span><span class="p">]</span><span class="n">h_s</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nevents</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> [<span class="p">::</span><span class="mf">1</span><span class="p">]</span><span class="n">s0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nevents</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> [<span class="p">::</span><span class="mf">1</span><span class="p">]</span><span class="n">s_s</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nevents</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> [<span class="p">::</span><span class="mf">1</span><span class="p">]</span><span class="n">k0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nevents</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> [<span class="p">::</span><span class="mf">1</span><span class="p">]</span><span class="n">sg</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nevents</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> [<span class="p">::</span><span class="mf">1</span><span class="p">]</span><span class="n">sd</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nevents</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> [<span class="p">::</span><span class="mf">1</span><span class="p">]</span><span class="n">proposal_normalisation</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nevents</span><span class="p">))</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> [<span class="p">::</span><span class="mf">1</span><span class="p">]</span><span class="n">prior_dc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nevents</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">dc_prior</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="o">==</span><span class="mf">0</span><span class="p">:</span>
        <span class="n">prior_dc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">])</span>
    <span class="k">cdef</span> <span class="kt">int</span> <span class="nf">index</span>
    <span class="k">if</span> <span class="n">gaussian_jump</span><span class="p">:</span>
        <span class="n">jump_params_fn</span><span class="o">=&amp;</span><span class="n">gaussian_jump_prob</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">jump_params_fn</span><span class="o">=&amp;</span><span class="n">flat_jump_prob</span>
    <span class="k">if</span> <span class="n">uniform_prior</span><span class="p">:</span>
        <span class="n">prior_ratio_fn</span><span class="o">=&amp;</span><span class="n">uniform_prior_ratio</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">prior_ratio_fn</span><span class="o">=&amp;</span><span class="n">flat_prior_ratio</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nevents</span><span class="p">):</span>
        <span class="n">g0</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">x0</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;gamma&#39;</span><span class="p">]</span>
        <span class="n">g_s</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">alpha</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;gamma&#39;</span><span class="p">]</span>
        <span class="n">d0</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">x0</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;delta&#39;</span><span class="p">]</span>
        <span class="n">d_s</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">alpha</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;delta&#39;</span><span class="p">]</span>
        <span class="n">h0</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">x0</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;h&#39;</span><span class="p">]</span>
        <span class="n">h_s</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">alpha</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;h&#39;</span><span class="p">]</span>
        <span class="n">s0</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">x0</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;sigma&#39;</span><span class="p">]</span>
        <span class="n">s_s</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">alpha</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;sigma&#39;</span><span class="p">]</span>
        <span class="n">k0</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">x0</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;kappa&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s">&#39;proposal_normalisation&#39;</span> <span class="ow">in</span> <span class="n">alpha</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">proposal_normalisation</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">alpha</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;proposal_normalisation&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s">&#39;gamma_dc&#39;</span> <span class="ow">in</span> <span class="n">alpha</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">sg</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">alpha</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;gamma_dc&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s">&#39;delta_dc&#39;</span> <span class="ow">in</span> <span class="n">alpha</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">sd</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">alpha</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;delta_dc&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dc_prior</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="o">==</span><span class="mf">1</span><span class="p">:</span>
            <span class="n">prior_dc</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">dc_prior</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">dc_prior</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mf">1</span><span class="p">:</span>
            <span class="n">prior_dc</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">dc_prior</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">umax</span><span class="p">):</span>
            <span class="n">gamma</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">][</span><span class="s">&#39;gamma&#39;</span><span class="p">]</span>
            <span class="n">delta</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">][</span><span class="s">&#39;delta&#39;</span><span class="p">]</span>
            <span class="n">kappa</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">][</span><span class="s">&#39;kappa&#39;</span><span class="p">]</span>
            <span class="n">sigma</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">][</span><span class="s">&#39;sigma&#39;</span><span class="p">]</span>
            <span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">][</span><span class="s">&#39;h&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s">&#39;g0&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">qg</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">][</span><span class="s">&#39;g0&#39;</span><span class="p">]</span><span class="c">#g0 from mt sample ==&gt; dc sample</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">qg</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">][</span><span class="s">&#39;gamma&#39;</span><span class="p">];</span><span class="c">#no g0  ==&gt;  mt sample</span>
            <span class="k">if</span> <span class="s">&#39;d0&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">qd</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">][</span><span class="s">&#39;d0&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">qd</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">][</span><span class="s">&#39;delta&#39;</span><span class="p">];</span>
    <span class="n">index</span><span class="o">=</span><span class="n">c_me_acceptance_check</span><span class="p">(</span><span class="n">transition_ratio_fn</span><span class="p">,</span><span class="n">prior_ratio_fn</span><span class="p">,</span><span class="n">jump_params_fn</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span> <span class="n">g0</span><span class="p">,</span> <span class="n">g_s</span><span class="p">,</span> <span class="n">d0</span><span class="p">,</span> <span class="n">d_s</span><span class="p">,</span> <span class="n">h0</span><span class="p">,</span> <span class="n">h_s</span><span class="p">,</span> <span class="n">s0</span><span class="p">,</span> <span class="n">s_s</span><span class="p">,</span><span class="n">ln_p</span><span class="p">,</span><span class="n">ln_p0</span><span class="p">,</span><span class="n">k0</span><span class="p">,</span><span class="n">qg</span><span class="p">,</span><span class="n">qd</span><span class="p">,</span><span class="n">sg</span><span class="p">,</span><span class="n">sd</span><span class="p">,</span><span class="n">proposal_normalisation</span><span class="p">,</span><span class="n">prior_dc</span><span class="p">)</span>
    <span class="n">returnx</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nevents</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span><span class="o">&gt;=</span><span class="mf">0</span><span class="p">:</span>
            <span class="n">returnx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">index</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">returnx</span><span class="o">.</span><span class="n">append</span><span class="p">({})</span>
    <span class="k">if</span> <span class="n">index</span><span class="o">&gt;=</span><span class="mf">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">returnx</span><span class="p">,</span><span class="n">ln_p</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="n">index</span>
    <span class="k">return</span> <span class="n">returnx</span><span class="p">,</span><span class="bp">False</span><span class="p">,</span><span class="n">umax</span>

<span class="c">#Python function for new sample</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">nonecheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">new_samples</span><span class="p">(</span><span class="nb">dict</span> <span class="n">x0</span><span class="p">,</span><span class="nb">dict</span> <span class="n">alpha</span><span class="p">,</span><span class="n">Py_ssize_t</span> <span class="n">number_samples</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">dc</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">DTYPE_t</span> <span class="n">jump</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="nb">bool</span> <span class="n">gaussian_jump</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">cdef</span> <span class="kt">Py_ssize_t</span> <span class="nf">u</span>
    <span class="k">cdef</span> <span class="kt">list</span> <span class="nf">x</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="nf">zero</span><span class="o">=</span><span class="mf">0.0</span>
    <span class="k">cdef</span> <span class="kt">dict</span> <span class="nf">_x</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;gamma&#39;</span><span class="p">:</span><span class="n">zero</span><span class="p">,</span><span class="s">&#39;delta&#39;</span><span class="p">:</span><span class="n">zero</span><span class="p">,</span><span class="s">&#39;kappa&#39;</span><span class="p">:</span><span class="n">zero</span><span class="p">,</span><span class="s">&#39;h&#39;</span><span class="p">:</span><span class="n">zero</span><span class="p">,</span><span class="s">&#39;sigma&#39;</span><span class="p">:</span><span class="n">zero</span><span class="p">}</span> 
    <span class="k">cdef</span> <span class="kt">DTYPE_t</span>[<span class="p">:,::</span><span class="mf">1</span><span class="p">]</span> <span class="n">M</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mf">6</span><span class="p">,</span><span class="n">number_samples</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_samples</span><span class="p">):</span>
        <span class="n">_x</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;gamma&#39;</span><span class="p">:</span><span class="n">zero</span><span class="p">,</span><span class="s">&#39;delta&#39;</span><span class="p">:</span><span class="n">zero</span><span class="p">,</span><span class="s">&#39;kappa&#39;</span><span class="p">:</span><span class="n">zero</span><span class="p">,</span><span class="s">&#39;h&#39;</span><span class="p">:</span><span class="n">zero</span><span class="p">,</span><span class="s">&#39;sigma&#39;</span><span class="p">:</span><span class="n">zero</span><span class="p">}</span> 
        <span class="k">if</span> <span class="n">jump</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">&lt;</span><span class="n">jump</span><span class="p">:</span>
            <span class="n">_x</span><span class="p">[</span><span class="s">&#39;kappa&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">x0</span><span class="p">[</span><span class="s">&#39;kappa&#39;</span><span class="p">]</span>
            <span class="n">_x</span><span class="p">[</span><span class="s">&#39;h&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">x0</span><span class="p">[</span><span class="s">&#39;h&#39;</span><span class="p">]</span>
            <span class="n">_x</span><span class="p">[</span><span class="s">&#39;sigma&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">x0</span><span class="p">[</span><span class="s">&#39;sigma&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">x0</span><span class="p">[</span><span class="s">&#39;gamma&#39;</span><span class="p">]</span><span class="o">==</span><span class="mf">0.0</span> <span class="ow">and</span> <span class="n">x0</span><span class="p">[</span><span class="s">&#39;delta&#39;</span><span class="p">]</span><span class="o">==</span><span class="mf">0.0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">gaussian_jump</span><span class="p">:</span>
                    <span class="n">_x</span><span class="p">[</span><span class="s">&#39;gamma&#39;</span><span class="p">],</span><span class="n">_x</span><span class="p">[</span><span class="s">&#39;delta&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">gaussian_jump_params</span><span class="p">(</span><span class="n">alpha</span><span class="p">[</span><span class="s">&#39;gamma_dc&#39;</span><span class="p">],</span><span class="n">alpha</span><span class="p">[</span><span class="s">&#39;delta_dc&#39;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_x</span><span class="p">[</span><span class="s">&#39;gamma&#39;</span><span class="p">],</span><span class="n">_x</span><span class="p">[</span><span class="s">&#39;delta&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">flat_jump_params</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_x</span><span class="p">[</span><span class="s">&#39;gamma&#39;</span><span class="p">]</span><span class="o">=</span><span class="mf">0.0</span>
                <span class="n">_x</span><span class="p">[</span><span class="s">&#39;delta&#39;</span><span class="p">]</span><span class="o">=</span><span class="mf">0.0</span>
                <span class="n">_x</span><span class="p">[</span><span class="s">&#39;g0&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">x0</span><span class="p">[</span><span class="s">&#39;gamma&#39;</span><span class="p">]</span>
                <span class="n">_x</span><span class="p">[</span><span class="s">&#39;d0&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">x0</span><span class="p">[</span><span class="s">&#39;delta&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dc</span> <span class="ow">or</span> <span class="n">x0</span><span class="p">[</span><span class="s">&#39;gamma&#39;</span><span class="p">]</span><span class="o">==</span><span class="mf">0.0</span> <span class="ow">and</span> <span class="n">x0</span><span class="p">[</span><span class="s">&#39;delta&#39;</span><span class="p">]</span><span class="o">==</span><span class="mf">0.0</span><span class="p">:</span>
                <span class="n">_x</span><span class="p">[</span><span class="s">&#39;gamma&#39;</span><span class="p">]</span><span class="o">=</span><span class="mf">0.0</span>
                <span class="n">_x</span><span class="p">[</span><span class="s">&#39;delta&#39;</span><span class="p">]</span><span class="o">=</span><span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_x</span><span class="p">[</span><span class="s">&#39;gamma&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">new_gamma</span><span class="p">(</span><span class="o">&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">x0</span><span class="p">[</span><span class="s">&#39;gamma&#39;</span><span class="p">],</span><span class="o">&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">alpha</span><span class="p">[</span><span class="s">&#39;gamma&#39;</span><span class="p">])</span>
                <span class="n">_x</span><span class="p">[</span><span class="s">&#39;delta&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">new_delta</span><span class="p">(</span><span class="o">&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">x0</span><span class="p">[</span><span class="s">&#39;delta&#39;</span><span class="p">],</span><span class="o">&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">alpha</span><span class="p">[</span><span class="s">&#39;delta&#39;</span><span class="p">])</span>
            <span class="n">_x</span><span class="p">[</span><span class="s">&#39;kappa&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">new_kappa</span><span class="p">(</span><span class="o">&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">x0</span><span class="p">[</span><span class="s">&#39;kappa&#39;</span><span class="p">],</span><span class="o">&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">alpha</span><span class="p">[</span><span class="s">&#39;kappa&#39;</span><span class="p">])</span>
            <span class="n">_x</span><span class="p">[</span><span class="s">&#39;h&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">new_h</span><span class="p">(</span><span class="o">&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">x0</span><span class="p">[</span><span class="s">&#39;h&#39;</span><span class="p">],</span><span class="o">&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">alpha</span><span class="p">[</span><span class="s">&#39;h&#39;</span><span class="p">])</span>
            <span class="n">_x</span><span class="p">[</span><span class="s">&#39;sigma&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">new_sigma</span><span class="p">(</span><span class="o">&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">x0</span><span class="p">[</span><span class="s">&#39;sigma&#39;</span><span class="p">],</span><span class="o">&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">alpha</span><span class="p">[</span><span class="s">&#39;sigma&#39;</span><span class="p">])</span>
        <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_x</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">m</span><span class="o">=</span><span class="n">convert_sample</span><span class="p">(</span> <span class="n">_x</span><span class="p">[</span><span class="s">&#39;gamma&#39;</span><span class="p">],</span> <span class="n">_x</span><span class="p">[</span><span class="s">&#39;delta&#39;</span><span class="p">],</span> <span class="n">_x</span><span class="p">[</span><span class="s">&#39;kappa&#39;</span><span class="p">],</span> <span class="n">_x</span><span class="p">[</span><span class="s">&#39;h&#39;</span><span class="p">],</span> <span class="n">_x</span><span class="p">[</span><span class="s">&#39;sigma&#39;</span><span class="p">])</span>
        <span class="n">M</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span>
        <span class="n">M</span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span>
        <span class="n">M</span><span class="p">[</span><span class="mf">2</span><span class="p">,</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="mf">2</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span>
        <span class="n">M</span><span class="p">[</span><span class="mf">3</span><span class="p">,</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="mf">3</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span>
        <span class="n">M</span><span class="p">[</span><span class="mf">4</span><span class="p">,</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="mf">4</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span>
        <span class="n">M</span><span class="p">[</span><span class="mf">5</span><span class="p">,</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="mf">5</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="source-probability.html" class="btn btn-neutral float-right" title="3.1.3. MTfit.probability" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="source-monte_carlo.html" class="btn btn-neutral" title="3.1.2.2.2. MTfit.algorithms.monte_carlo" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, David Pugh.
      Last updated on Jan 29, 2018 (version 1.0.2).

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>